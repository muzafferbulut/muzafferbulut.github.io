[ { "title": "NoSQL Veri Tabanı Yönetim Sistemleri", "url": "/posts/nosql-database-management-systems/", "categories": "MongoDB, NoSQL", "tags": "mongodb, nosql, document based, collection, database", "date": "2023-09-25 09:30:30 +0300", "snippet": " 1. Giriş Veri tabanı yönetim sistemlerinin dönüşümü ve gelişimini 3 aşamada incelemek mümkündür. İlk aşamada veriler ilkel bilgisayarlarda sıralı bantlar halinde saklanırken veriye erişim ve yönet...", "content": " 1. Giriş Veri tabanı yönetim sistemlerinin dönüşümü ve gelişimini 3 aşamada incelemek mümkündür. İlk aşamada veriler ilkel bilgisayarlarda sıralı bantlar halinde saklanırken veriye erişim ve yönetim için gelişmiş kodlama bilgisi gerekiyordu. Bilgisayar teknolojilerinin gelişimi henüz olgunlaşmamışken veri operasyonları, sorgulama ve raporlama işlemleri için efor harcamak gerekiyordu.1970'li yıllara gelindiğinde E.F. Codd tarafından yayımlanan bir makale ile günümüzde de halen yoğun olarak kullanılan ilişkisel veri tabanı modelinin temelleri atıldı. Verileri tablolar halinde ele alan, tablolar arası kurulan ilişkiler ile çapraz sorgulama olanağı tanıyan ilişkisel veri tabanı modeli günümüzde verinin hayati önem taşıdığı uygulamalarda tercih edilmektedir. ACID (Atomicity, Consistency, Isolation, Durability) ilkeleri ile veri tutarlılığı açısından avantaj sağlayan bu model SQL ile de veri erişimi, yönetimi ve raporlama gibi işlemlerde de gelişmiş kodlama bilgisi gerekliliğini ortadan kaldırmıştır.Gelişen teknoloji veri kaynaklarının çeşitlenmesine, veri boyutunun ve depolama maliyetlerinin daha hızlı yükselmesine sebep oldu. Farklı kaynaklardan toplanan, yapısal olmayan, yatay ve düşey olarak hızlı büyüyen veri yığını olarak adlandırılan bu yapıya büyük veri kümesi adı verilir. İlişkisel veri tabanı yönetim sistemleri yapısal veri kümelerini yönetmek ve sorgulamak için tasarlandığından büyük veri için optimmum çözüm değildir. Sorgulama, raporlama, ölçeklenebilirlik ve performans problemlerinin yanında depolama maliyetleri de hızla artmaktadır. Bu probleme çözüm olarak NoSQL veri tabanı yönetim sistemleri önerilmiştir.NoSQL veri tabanı yönetim sistemleri yapısal olmayan, farklı kaynaklardan toplanan, yatay ve dikey olarak hızlı büyüyen veri setlerini optimum maliyetle depolamak ve bu veri setlerinden faydalı bilgi çıkarmak için bir çözüm sunar. ACID ilkelerine karşılık olarak NoSQL veri tabanı yönetim sistemlerinde BASE (Basically Avaliable, Soft State, Eventually Consistent) ilkeleri benimsenmiştir. Bu ilkeler sayesinde NoSQL veri tabanı yönetim sistemleri esnek, kolay ölçeklenebilir ve yüksek performanslı bir yapıya sahip olmuştur. 2. NoSQL Veri Tabanı Yönetim Sistemi Tipleri NoSQL sistemler veri saklama ve okuma yöntemleri açısından çeşitlilik gösterir ve temel anlamda 4 bölümde incelenebilir. 2.1. Anahtar - Değer (Key-Value) Modeli Anahtar-değer veri modeli en basit ve en verimli yapılardan biridir. Hash tablo kullanılması fikri üzerine inşa edilmiş olan bu veri tabanı modeli benzersiz anahtarlar ve bu anahtarlar ile ilişkilendirilmiş verilerden oluşur. Dolayısıyla bu sistem bir anahtar-deper deposu olarak düşünülebilir. Anahtarlar indeks kullandığı için ilişkisel veri tabanı modeline göre daha hızlı olmasına karşın veri boyutu arttıkça verimlilik düşer. Tutarlılık yerine yüksek ölçeklenebilirliği benimseyen bu sistemde belli sorgu senaryolarında yüksek performans potansiyeli olmasına rağmen karmaşık sorgulamalar yapma yeteneği kısıtlıdır. Forumlar, alışveriş siteleri, uygulamalar için önbellekleme gibi uygulama alanlarıda kullanılmaktadır. Örnek olarak Redist, Hazelcaast ve DynamoDB verilebilir. 2.2. Sütun Bazlı (Wide Column) Modeli Büyük hacimde verileri dağıtık olarak depolayabilmek için geliştirilmiş veri modelidir. Yapı olarak ilişkisel ve anahtar-değer veri tabanı modelleri arasında yer alır. İlişkisel veri tabanı modelinden farklı olarak veriler birbiri ile ilişkilendirimiş sütunlarda tutulur. Veri depolamada yüksek ölçeklenebilirlik sunar ancak maliyet ve performans problemleri vardır. Mesajlaşma sistemleri, veri madenciliği ve analitik uygulamalar için kullanılabilir. Örnek olarak Cassandra ve HBASE verilebilir. 2.3. Belge Tabanlı (Document Based) Modeli Belge tabalı modelde veriler versiyonlanmış belgeler halinde tutulur. Eğer kullanıcı tarafından belirtilmediyse her belgeye bir eşsiz değer atanır. Bir veri tabanındaki belgeler farklı alanlara sahip olabileceği gibi iç içe geçmiş belgeler de oluşturulabilir. Belgelerin içeriği ilişkisel veri tabanlarına benzese de veriler belli bir şemaya zorlanmadığı için yata ölçeklenebilirlik ve esneklik gibi avantajları vardır. İçerik yönetim sistemi, blog yazımı, sosyal medya uygulamaları, loglama işlemleri, sensör verilerinin depolanması gibi alanlarda kullanılabilir. Örnek olarak MongoDB ve CouchDB ortamları verilebilir. 2.4. Graf (Graph Based) Modeli Diğer veri tabanı türlerine nazaran daha az kullanılan graf tabanı veri tabanı türleri birbirine bağlı olan verileri yönetme yeteneği öne çıkar. Graf tabanlı veri tabanı sistemleri düğümler ve düğümler birbirine bağlayan kenarlardan oluşur. Düğümler nesneleri, kenarlar ise nesneler arasındaki ilişkileri temsil eder. ACID ilkelerine uyumludur ve hızlı ve kolay ölçeklenebilir yapıdadır. Sosyal medya uygulamaları, en yakın rotayı bulma, içerik yönetimi, güvenlik ve erişim kontrolü gibi uygulama alanlarında kullanılır. Örnek olarak Neo4J, InfoGrid ve InfoGraph verilebilir." }, { "title": "PostgreSQL Trigger Yapıları", "url": "/posts/postgresql-triggers/", "categories": "PostgreSQL, SQL", "tags": "postgresql, views, SQL, triggers, gis", "date": "2023-04-01 09:30:30 +0300", "snippet": " 1. Giriş PostgreSQL Trigger bir tabloyla ilişkili insert, update, delete ve truncate işlemleri meydana geldiğinde çağrılan kullanıcı tanımlı bir fonksiyondur. Bu özellik veri tabanı işlemerinin da...", "content": " 1. Giriş PostgreSQL Trigger bir tabloyla ilişkili insert, update, delete ve truncate işlemleri meydana geldiğinde çağrılan kullanıcı tanımlı bir fonksiyondur. Bu özellik veri tabanı işlemerinin daha esnek hale getirilmesine ve özelleştirilmesine olanak sağlar. Bir fonksiyon oluşturulur ve ilgili tablo ile bağlanır. Tabloya bağlanırken hangi değişikliklerde bu fonksiyonun tetikleneceği de belirtilir. İlgili tabloda belirtilen değişiklikler gerçekleştiğinde fonksiyon tetiklenerek işlevini yerine getirir.Diğer kullanıcı tanımlı fonksiyonlar ile farkı ise belirtilen işlem gerçekleştiğinde kendiliğinden tetiklenmesidir. Diğer kullanıcı tanımlı fonksiyonlarda kullanıcı yazdığı SQL scripti içinde fonksiyonu kendisi çağırarak kullanır. Trigger ise uygun şartlar oluştuğunda fonksiyon çalışarak işlevini yerine getirecektir.PostgreSQL satır ve ifade düzeyi olmak üzere 2 tip trigger tipi sağlar. Satır düzeyindeki trigger fonksiyonları değişen satır kadar tetiklenirken ifade düzeyinde triggger yapıları değiştiren ifade (UPDATE, INSERT, DELETE TRUNCATE) kadar tetiklenir. Triggerlar, veri tabanı işlemlerini denetlemek ve özelleştirmek için kullanılabilir. Örneğin, bir trigger, belirli bir tablodaki verileri otomatik olarak değiştirebilir veya silebilir. Ayrıca, triggerlar, veri tabanı güvenliğini artırmak için de kullanılabilir. Örneğin, bir trigger, belirli bir tablodan veri silinirken bir kayıt tutabilir ve bu kaydı daha sonra denetim amaçlı kullanabilir. 2. Database Trigger Kullanıcı tanımlı fonksiyonlara benzeyen trigger, herhangi bir değişken almaz. Bir trigger şu şekilde tanımlanır.CREATE TRIGGER trigger_name{ BEFORE | AFTER } { event [ OR ... ] }ON table_name[ FROM referenced_table_name ][ NOT DEFERRABLE | [ DEFERRABLE ] [ INITIALLY IMMEDIATE | INITIALLY DEFERRED ] ][ FOR [ EACH ] { ROW | STATEMENT } ][ WHEN ( condition ) ]EXECUTE FUNCTION function_name ( arguments );Burada trigger'ın hangi şartlarda tetikleneceği event kısmında belirtilir. Table name kısmı trigger'ın bağlı olduğu tablonun adıdır. Execute Function kısmında trigger'ın çalıştırmasını istediğimiz fonksiyon yer alır. Örneğin worker_status tablosunda bir değişiklik olduğunda bildirim göndermek için şöyle bir trigger yazılabilir.CREATE OR REPLACE FUNCTION send_notification()RETURNS trigger AS $$BEGIN -- bildirim gönderEND;$$ LANGUAGE plpgsql;CREATE TRIGGER notify_changesAFTER INSERT OR UPDATE OR DELETEON worker_statusFOR EACH ROWEXECUTE FUNCTION send_notification();Bir tablodan trigger silmek için drop deyimi ile birlikte aşağıdaki söz dizimi kullanılır.DROP TRIGGER [IF EXISTS] trigger_name ON table_name [ CASCADE | RESTRICT ];Alter deyimi ile daha önceden oluşturulan trigger yeniden adlandırılabilir.ALTER TRIGGER trigger_nameON table_name RENAME TO new_trigger_name;Bir trigger alter table disable trigger deyimi kullanılarak devre dışı bırakılır.ALTER TABLE table_nameDISABLE TRIGGER trigger_name | ALLBir trigger veya bir tabloyla ilişkili tüm trigger'ları etkinleştirmek için ALTER TABLE ENABLE TRIGGER deyimini kullanılır.ALTER TABLE table_nameENABLE TRIGGER trigger_name | ALL; 3. Server Trigger Server triggerlar, veritabanı yönetim sistemleri tarafından desteklenen özel bir nesnedir. Bu triggerlar, belirli bir veritabanı sunucusunda gerçekleşen olaylar (örneğin, bağlantı açma, bağlantı kesme, sorgu çalıştırma vb.) tetiklendiğinde otomatik olarak çalışan özel işlevlerdir.Server triggerlar, veritabanı yönetim sistemleri tarafından desteklenen birçok olay için kullanılabilir. Örneğin, bir sunucuya yeni bir bağlantı açıldığında otomatik olarak belirli bir sorgu çalıştırılabilir veya bir bağlantı kesildiğinde otomatik olarak belirli bir işlem gerçekleştirilebilir.Server triggerlar, özellikle veritabanı yönetimi için otomasyon sağlamak için çok kullanışlıdır. Örneğin, bir server trigger, belirli bir veritabanı sunucusunda bir kullanıcının belirli bir tabloya erişmesini engelleyebilir veya belirli bir sorgu çalıştırıldığında otomatik olarak bir rapor oluşturabilir. Şifre denemelerini denetleyerek tehlikeli bir durumda ip'yi kara listeye alabilir." }, { "title": "PostgreSQL View Yapıları", "url": "/posts/postgresql-views/", "categories": "PostgreSQL, SQL", "tags": "postgresql, views, gis", "date": "2023-03-10 09:30:30 +0300", "snippet": " 1. Giriş SQL ile veri tabanını sorgulamak, veri filtrelemek ya da raporlama yapmak gerektiğinde her zaman basit SQL cümleleri yazmayız. Karmaşık sorgular yazmak, raporlar hazırlamak gerekebilir. A...", "content": " 1. Giriş SQL ile veri tabanını sorgulamak, veri filtrelemek ya da raporlama yapmak gerektiğinde her zaman basit SQL cümleleri yazmayız. Karmaşık sorgular yazmak, raporlar hazırlamak gerekebilir. Aynı SQL sorgusu farklı zamanlarda ve aynı uygulamanın farklı kısımlarında kullanılıyor da olabilir. Bu gibi durumlarda aynı komplex sorguyu defalarca yazmamak, gerektiğinde kolaylıkla çağırabilmek adına view yapıları kullanılır. Bir view oluşturulduğunda temel olarak karmaşık bir SQL sorgusunda isim atamış oluruz, bu nedenle arka planda bir veri değil SQL cümlesi tutulur. 2. PostgreSQL’de View Yapılarını Yönetmek View yapıları arka planda veri değil bir SQL sorgusu saklar. Bu sorgu çoğu zaman birden fazla tablonun join yapılara birleştirilmiş oldukça kapsamlı ve karmaşık bir sorgudur. View olarak tanımlanmış bu sorgunun sonucuna temel anlamda mantıksal bir tablo gibi SELECT deyimi ile erişilebilir. View'lar için basit anlamda create ve select yapıları aşağıdaki gibidir.-- create view deyimi \"or replace\" deyimi ile birlikte kullanılırsa daha-- sonradan view tanımı değiştirilebilir.CREATE VIEW OR REPLACE view_name AS SELECT a.id, a.col1, a.col2, b.id, b.col1 FROM table_a a INNER JOIN table_b b ON b.id = a.b_id; -- burada view olarak oluşurulacak view_name ile çağrılacak -- sorgunun tamamı yer alacaktır.-- select viewSELECT * FROM view_name;Bir view'in tanımını değiştirmek için alter deyimi bir view'ı silmek için ise drop deyimi kullanılır. Örneğin bir view'ın ismini değiştirmek için aşağıdaki komut kullanılabilir.-- view adını değiştirmekALTER VIEW table_a RENAME TO table_a_rename;-- var olan bir view'ı silmekDROP VIEW IF EXISTS table_a_rename;Temel olarak view yapıları bir SQL sorgusuna isim atanarak karmaşık sorguların basitleştirilmesine, kullanıcıların görme yetkilerine sahip olduğu alanların view olarak tanımlanması yoluyla ise yetkilendirme gibi konularda fayda sağlar.View yapıları temel anlamda bir SQL sorgusu tuttuğu için insert, update, delete gibi işlemler yapılamaz. Ancak bazı özel kouşllar altında bu komutları sisteme gönderme imkanı vardır. Ama öyle bir durumda da yine işlem view'ın kullandığı tabloda yapılacağından verinin bulunduğu yerde bu işlemi yapmak daha sağlıklıdır. 3. Materialized Views Basit bir view kullanımında select deyimi ile view çağrıldığında arka planda aslında view'ın tuttuğu SQL sorgusu çalıştırılır. Bu işlem büyük veri tabanlarında her seferinde yeniden çalışacak bir karmaşık SQL sorgusu demektir. Dolayısıyla performans kaybı kaçınılmaz olur. Bu gibi durumlarda zaman ve performans avantajı sağlamak için PostgreSQL view kavramını verilerin fiziksel olarak depolanabildiği Materialized View'a genişletir.Materialized view yapılarında karmaşık sorgu sonucu önbelleğe alınır ve periyodik aralıklarla güncelleme yapışabilir. Dolayısıyla hem performans avantajı sağlanır hem de veri güncel tutulur. Sağladığı avantaj dolayısıyla genellikle performans gerektiren veri ambarı ve iş zekası uygulamalarında kullanılır. Aşağıdaki şekilde bir materialized view tanımlanabilir.-- materialized view oluşturmaCREATE MATERIALIZED VIEW view_name asSELECT * FROM table_aWITH [NO] DATA;With deyimi materialized view'lar oluşturulurken içine veri eklemek için kullanılır. View oluşturulurken içine veri eklenmezse boş bir view olacağı için veri eklenene kadar okunma işlemi yapılamaz.Bir materialized view oluşturduk, güncelleme işlemlerini nasıl yapacağız? Materialized view yapıları önbellekte veri tuttuğu için güncelleme işlemleri atlanmamalıdır. Yetersiz güncelleme işlemi güncel veriye daha geç ulaşmamıza sebep olabilir.-- verileri yüklemeREFRESH MATERIALIZED VIEW view_name;Ancak bu kullanım sırasında tablo kilitleneceği için sorgu atılamaz. Bu sebeple aşağıdaki kullanım önerilir.REFRESH MATERIALIZED VIEW CONCURRENTLY view_name;Bu işlemde view'ın geçici olarak güncellenmiş bir sürümü oluşturulur ve aradaki farklar kontrol edilir. 4. Recursive View PostgreSQL 9.3 sürümü ile birlike bir standart haline gelen recursive (özyinelemeli view) kendi kendini çağıran view'ların oluşturulmasını ifade eder. Aşağıdaki şekilde oluşturulur.-- view oluşturmakCREATE RECURSIVE VIEW view_name(columns) asSELECT columns-- ya daCREATE VIEW view_name AS WITH RECURSIVE cte_name (columns) AS (  SELECT ...) SELECT columns FROM cte_name;" }, { "title": "Ubuntu Üzerine PostgreSQL Kurulumu", "url": "/posts/postgresql-installation-on-ubuntu/", "categories": "PostgreSQL, Administration", "tags": "postgresql, ubuntu, linux, kurulum", "date": "2023-02-04 21:30:30 +0300", "snippet": "PostgreSQL veri tabanı dünyasının en hızlı ve güvenli açık kaynak kodlu veri tabanı yönetim sistemlerinden biridir. Arkasına aldığı açık kaynak kod topluluğunundesteğiyle gelişmeye devam etmektedir...", "content": "PostgreSQL veri tabanı dünyasının en hızlı ve güvenli açık kaynak kodlu veri tabanı yönetim sistemlerinden biridir. Arkasına aldığı açık kaynak kod topluluğunundesteğiyle gelişmeye devam etmektedir. Artan lisans maliyetlerinden ötürü de bir çok kurum veri tabanı yönetim sistemi olarak PostgreSQL tercih etmektedir.Ubuntu linux tabanlı özgür ve ücretsiz bir işletim sistemidir. PostgreSQL varsayılan olarak tüm ubuntu sürümlerinde mevcuttur ve postgresin alternatif sürümlerine depostgresql apt deposundan erişilebilir.PostgreSQL'i en güncel haliyle kurmak için öncelikle kullanılan ubuntu depolarının güncellenmiş olması gerekmektedir. Terminalde update komutu çalıştırıp depoları güncelleyerek kurulum başlatılabilir.$ sudo apt-get updateDepoların güncellenmesi tamamlandıktan sonra Postgresql kuruluman başlanır. Aşağıdaki komut kullanılarak PostgreSQL paketleri indirilir.$ sudo apt-get install postgresql postgresql-contribKomutun çalışması tamamlandğında postgresql kurulmuş olacaktır. Spesifik bir sürüm kurulmak isteniyorsa postgresql parametresi sonuna (örneğin postgresql-12) eklenebilir. postgresql-contrib paketi temel özellikler için gerekli değildir ancak veri tabanı sistemi için ek araç ve eklentiler içermektedir. Örneğin bu paket veri tabanı yönetimi ve veri işleme gibi uygulamalar için eklentiler ve veri tabanı güvenliğini artırmak için araçlar içerebilir. PostgreSQL'in kurulduğu dizin incelenecek olursa veri tabanı için gerekli olan konfigürasyon dosyaları görülür.$ ls /etc/postgresql/14/main-- conf.d, environment, pg_ctl.conf, pg_hba.conf, pg_ident.conf, start.confconf.d dizini PostgreSQL veri tabanı yapılandırması için kullanılan eklenti dosyalarınıns saklandığı dizindir. Bu dosyalar veri tabanı yapılandırmasının bazı özelliklerini değiştirmek için kullanılabilir. Environment dizini veri tabanının çalıştığı esnada kullanılacak ortam değişkenlerini saklamak için kullanılır. pg_ctl.conf PostgreSQL veri tabanının kontrol edilmesi için kullanılan bir yapılandırma dosyasıdır. Veri tabanı servisinin başlatılması, durdurulması gibi işlemlerin kontrol edilmesinde kullanılır. Bu süreçlerde kullanılmak üzere belirli parametre ve ayarlar pg_ctl.conf dosyası aracılığıyla yapılır. pg_hba.conf (Host Based Authentication Conf) dosyası ile veri tabanının erişim denetimi yapılır. Bu konfigürasyon dosyası veri tabanına bağlantı isteği atan kullanıcıların hangi IP adresleri ve makine adları üzerinden ve hangi yetkilerle erişime izin verileceğini tanımlar. Veri tabanı gizliliği ve güvenliği konusunda önemli rol oynar. pg_ident.conf (PostgreSQL Identification Mapping Conf) dosyası PostgreSQL veri tabanında kullanıcı tanımlama işlemleri için kullanılan bir konfigürasyon dosyasıdır. Son olarak start.conf dosyası veri tabanının nasıl başlatılacağının tanımlandığı konfigürasyon dosyasıdır. Veritabanının başlatılması sırasında kullanması gereken belirli parametreleri ve ayarları tanımlar. Örneğin, veritabanının bellek kullanımı, dosya sistemi gibi özelliklerinin nasıl yapılandırılacağı bu dosya üzerinden belirlenebilir. Bu dosya, veritabanının performansını ve çalışmasını optimize etmek için önemli bir rol oynar.Veri tabanı servisinin durumunu öğrenmek için service postgresql komutu kullanılır. Bu komut veri tabanı hizmetinin durumunu görmemize, veri tabanı hizmetini başlatmamıza ve durdurmamıza olanak tanır.-- veri tabanı servisinin durumunu öğrenmek için$ service postgresql status-- veri tabanı servisini durdurmak için$ service postgresql stop-- veri tabanı servisini başlatmak için$ service postgresql start-- veri tabanı servisini yeniden başlatmak için$ service postgresql restartPostgreSQL kurulumu tamamnlandıktan sonra postgres adında bir sistem hesabı tanımlanır. Root kullanıcısından postgres kullanıcısına geçmek için sudo su postgres komutu kullanılaibilir. Ardından psql komutu vererek psql shell ekranına geçiş sağlanır." }, { "title": "Veri Tabanı Saldırıları ve Veri Tabanı Güvenliği", "url": "/posts/database-security/", "categories": "Not Defteri, Güvenlik", "tags": "sql, brute force, sql injection, veritabanı güvenliği, database security, sql server", "date": "2023-01-15 21:30:30 +0300", "snippet": " 1. Giriş Bilişim teknolojilerinde meydana gelen gelişim hizmetlerin çeşitlenmesine olanak tanımıştır. Bu süreçte birçok iş ve uygulama online ortama taşınmış, dijital dönüşüm kapsamında da taşınma...", "content": " 1. Giriş Bilişim teknolojilerinde meydana gelen gelişim hizmetlerin çeşitlenmesine olanak tanımıştır. Bu süreçte birçok iş ve uygulama online ortama taşınmış, dijital dönüşüm kapsamında da taşınmaya devam etmektedir. Bu durum insan hayatı için çok önemli kolaylıklar sağlıyor olsa da yeni tehditlerin de ortaya çıkmasına sebep olmaktadır. Olası mağduriyetleri engellemek için verilerin etkin bir şekilde depolanması ve korunması gereklidir.Gelişen dünyada hizmetlerden ve teknolojiden yararlanabilmek için çoğu zaman kişisel bilgilerimizi kullanıyoruz. Dolayısıyla bu durum verilerin etkin bir şekilde korunmasını zorunlu kılmaktadır. 2. Brute Force Saldırıları Brute Force kaba kuvvet anlamına gelmektedir. Temel prensibi sisteme erişerel çok sayıda giriş denemesi yapıp parolayı ele geçirmektir. Brute Force ile parola elde ediltikten sonra verileri dışarı çıkarma ve hatta format atmaya kadar ileri işlemler yapılabilir. En yaygın kullanılan saldırı yöntemlerinden biridir.Brute Force saldırılarının başarılı olmasında başta gelen sebeplerden biri veri tabanı default kullanıcılarını disable hale getirmemektir. Şifre denemeleri sırasında online ortamda kolaylıkla bulunabilen şifre sözlükleri kullanılmakta, default kullanıcılar ile denenmektedir ve bu bir güvenlik açığına sebep olmaktadır. Bu durumun önüne geçmek için default ayarları değiştirip, default kullanıcıları disable hale getirmenin yanında sistem belli bir yanlış şifre denemesinden sonra aynı kullanıcı için deneme yapmaya izin vermemelidir.Brute Force saldırılarında yerel ağda yapılan saldırılar çok önemlidir. İnternet üzerinden yapılan saldırılarda saniyede 15-20 tane deneme yapılabiliyorken yerel ağdan yapılan saldırılarda farklı yöntemlerle deneme sayısı 5 bin seviyelerine çıkmaktadır.Bu aşamada sisteme başarılı ve başarısız girişleri log'layan Login Auditing menüsünden başarısız girişler loglanabilir. Bu şekilde sık sık başarısız giriş yapmaya çalışan kaynaklar tespit edilerek engellenebilir. Sıklıkla başarısız şifre denemesi yapan IP kara listeye alınarak şifre doğru olsa bile veri tabanına girmesine izin vermeyecek bir server trigger yazılarakta brute force saldırılarına karşı önlem alınabilir. 3. SQL Injection Saldırıları SQL Injection zararlı olmayan SQL cümlelerinin arasına zararlı olacak kodların enjekte edilmesi işlemidir. Brute Force saldırısının aksine burada amaç şifre kırmak değildir. Bu saldırının yapılabilmesi için zaten veri tabanına bir şekilde bağlı olmak gerekmektedir. Örneğin hazırlanan bir programda bulunan bir açık veri tabanına sql cümlesi göndermeye olanak tanıyorsa kötü niyetli kişiler bu açıktan faydalanarak sadece SQL cümleleri kullanarak diske format atabilir. Farklı olarak yine SQL kullanırak zararlı bir yazılım sunucuya yüklenebilir. Bir SQL Injection saldırısında genellikle yapılan ilk şey bir kullanıcı eklemektir. Daha sonra bu kullanıcı aracılığıyla sisteme erişip zararlı faaliyetleri gerçekleştirmektir. Bu işlemlerin önüne geçmek için her yeni kullanıcı oluşuturulduğunda ilgili bilgileri mail atan bir server trigger yazılabilir. NOT: Notlar Sayın Ömer Çolakoğlu hocamızın BTK Akademi platformundaki Veri Tabanı Saldırıları ve Veri Tabanı Güvenliği kursu esnasında alınmış notlardır. Kendisine teşekkür ederim." }, { "title": "PostGIS Sorgu Performansı Artırma Teknikleri", "url": "/posts/postgis_performance/", "categories": "PostgreSQL, PostGIS", "tags": "postgresql, postgis, spatial database, spatial query performance", "date": "2022-12-10 21:30:30 +0300", "snippet": " 1. Giriş İlişkisel veri tabanı yönetim sistemlerinin en güçlü açık kaynak kodlu temsilcisi olan PostgreSQL, mekansal veri yönetimi açısından da sektörün en güçlü temsilcilerindendir. Arkasına açık...", "content": " 1. Giriş İlişkisel veri tabanı yönetim sistemlerinin en güçlü açık kaynak kodlu temsilcisi olan PostgreSQL, mekansal veri yönetimi açısından da sektörün en güçlü temsilcilerindendir. Arkasına açık kaynak kod topluluğunun gücünü alan PostgreSQL, 13 Ekim’de 15.1. sürümünün duyurulmasıyla gelişmeye ve geliştirilmeye devam etmektedir.PostGIS eklentisinin kurulması ile birlikte koordinat dönüşümü, geometri işleme, analiz etme, sorgulama, sınama, topolojik ilişkileri kontrol etme gibi işlevleri yerine getiren oldukça geniş bir fonksiyon havuzu kolaylıkla kullanılabilir duruma gelmektedir. 2. Geometri Sorguları Performans Artırma Teknikleri PostGIS vektör, raster, topoloji gibi eklentileri ile binden fazla fonksiyonu bünyesinde barındıran en verimli açık kaynak kodlu mekansal veri yönetimi aracıdır. Kurulumu ve kullanımı oldukça kolaydır. Yaygın olarak kullanılan GIS yazılımları ile kolaylıkla entegre edilebildiği için konum tabanlı uygulama geliştiricileri tarafından yoğun ilgi görmektedir. PostgreSQL veri tabanına basit bir prosedür izlenerek dahil edilir ve PostgreSQL’in sağladığı temel veri türlerini genişletir.PostGIS kendine has bir geometri tanımına sahiptir. Geometride artan kırık noktalar tanımın uzamasına ve dolayısıyla performans sorunlarının ortaya çıkmasına sebep olmaktadır. Veri hacmi büyük olan konumsal uygulamalarda performans önemli bir parametredir ve sorgu tasarımlarının performans kriteri göz önüne alınarak yapılması gerekmektedir. Mekansal fonksiyonların performansını önemli ölçüde artıran farklı yaklaşımlar mevcuttur. 2.1. Mekansal İndeksleme Mekansal verilerin tutulduğu tabloda temel bir st_intersects fonksiyonu çalıştırdığımızı düşünelim. PostgreSQL Explain Analyze aracı ile sorgunun nasıl çalıştığı incelenirse, tabloda temel bir arama yapıldığı görülür ki dikey olarak büyüyen verilerde bu durum maliyetin artmasına sebep olacaktır. Bu durumun önüne geçmek için uygulayabileceğimiz en kolay yöntemlerden biri mekansal indekslemedir. Tabloya eklenecek mekansal indeks ile sorgu süresi %97 oranında azalmaktadır. Mekansal indeks tüm tablo kayıtlarını taramak yerine ilgili boundary box alanında kalan kayıtların taraması yapılır. Boundary box geometri verisine nispeten çok basit yapıda olduğundan önemli fark yaratabilir, hatta bazı durumlarda yeterli olabilir. 2.1.1. GIST İndeks GIST (Generalized Search Tree) geometrik veri türlerini indekslemek için kullanılan bir ‘full text search’ aracıdır. BTree indeks genellikle karşılaştırma yapıları için kullanılırken GIST ağaç yapısında veri tutmasına karşın daha çok geometri ve text dokümanları gibi operatörler için kullanılmaktadır. 2.2. İndeks Sorguları Mekansal indeks eklenmiş bir tablodan veriyi hızlı bir şekilde sorgulamanın en hızlı yolu sadece indeks sorgularıdır. &amp;&amp; operatörü ile işlemleri boundary box üzerinden yapabiliriz. Ancak geniş alanlarda boundary box alanları da büyüyeceğinden potansiyel sonuç kümesi de büyür. Bir nehir geometrisi ele alınırsa, boundary box alanı nehrin kapladığı alan yanında oldukça büyük kalacaktır. Bu da potansiyel sonuçların sayısını artıracaktır. Yalnızca indeks sorguları yaparken gerçekleşen hız artışının gelen yanlış veri yükünü karşılayıp karşılamayacağının analizi yapılmalıdır. 2.3. Veriyi Alt Alanlara Bölme Yine bir nehir geometrisi düşünelim. Bir nehir geometrisi çok fazla kırık nokta içerir ve uzun bir çizgi ile ifade edilir. Dolayısıyla boundary box alanı gerçek alandan çok büyük olur. Mekansal indeksler işlemleri boundary box alanı üzerinden yaptığından PostGIS ilk aşamada nehirden çok uzakta olan geometrileri de dikkate alacak, ancak detaylı hesaplamaları yaptıktan sonra gerçek sonuca ulaşacaktır. Dikey olarak büyük tablolarda bu bir performans problemi yaratacaktır. Bundan kaçınmak için, nehri ifade eden boundary box alanını daha küçük parçalara bölerek bu parçaları farklı bir tabloda tutmak gerekir. Daha küçük ve daha basit olan bu alan parçaları muhtemel yanlış cevap sayılarını önemli ölçüde azaltacak, dönüş süresini de pozitif olarak etkileyecektir. Ancak bu çözümün de veritabanına insert ve depolanacak veride artış gibi bir maliyeti olacaktır. 2.4. Geometri Basitleştirme Karmaşık geometrilerde yer alan kırık noktalar sorgu sonuçları açısından her zaman önem arz etmeyebilir. Ancak bu geometri verileri sorgularda kullanılırken tüm detaylar dikkate alındığında sorgu maliyeti artar. Bu gibi durumlarda geometri verisi (örneğin st_simplify fonksiyonu ile) gerçeğe en yakın olacak şekilde basitleştirilir. Yani gereksiz detaylar geometriden çıkarılır. Bu - daha basit - geometriden yapılacak sorgu ya da analiz daha hızlı çalışacaktır. 3. Sonuç PostGIS tablolarında tutulan geometri verilerinin sorgulanması ve analizi esnasında performans açısından önemli fark yaratabilecek tekniklerin bazılarına değinmiş olduk. Elbette bu teknikler artırılabilir. Her durumda veri, proje ve sorgu tasarımına uygun tekniğin seçilmesi, gerekli durumlarda ar-ge çalışmalarının yapılması ve sonrasında uygulamaya geçilmesi maliyetleri azaltma açısından önemli olacaktır." }, { "title": "PostgreSQL Mimarisi", "url": "/posts/postgresql-arhitecture/", "categories": "PostgreSQL, Administration", "tags": "postgresql, mimari, spatial database, architecture", "date": "2022-11-20 21:30:30 +0300", "snippet": " 1. Giriş 70'li yıllarda önerilen ilişkisel veri tabanı modelinin en güçlü açık kaynak kodlu temsilcisi olan PostgreSQL, kullanıcılarına sağladığı avantajlar sayesinde halen etkin olarak kullanılma...", "content": " 1. Giriş 70'li yıllarda önerilen ilişkisel veri tabanı modelinin en güçlü açık kaynak kodlu temsilcisi olan PostgreSQL, kullanıcılarına sağladığı avantajlar sayesinde halen etkin olarak kullanılmaktadır. Güvenlik, hız, mekansal veri desteği gibi avantajlı özellikler sunan PostgreSQL lisans maliyetlerini de ortadan kaldırmıştır. Client-server mimarisinde multi-process hizmet veren bir ilişkisel veri tabanı yönetim sistemidir. Aynı zamanda mekansal veri desteği sunan ilk ilişkisel veri tabanı yönetim sistemlerinden biridir.PostgreSQL mimarisi memory, process ve disk üzerindeki dosyalardan oluşur. Process'ler postgres server, backend, background, replication associated process olmak üzere 4 ana başlıkta incelenebilir. 2. PostgreSQL Mimarisi 2.1. Postgres Server Process Önceki sürümlerde postmaster olarak adlandırılan postgres server process pg_ctl yardımcı programının start komutu ile postgres server başlatılır. Postgres server process server çalıştığında ayağa kalkan ilk process'tir ve diğer process'lerin parent process'idir. Sistem başlatıldığında shared memory'den postgresql server'in kullanacağı ram alanı allocate edilir ve background process'ler başlatılır. Varsa replication processler çalıştırılır ve sunucu kullanıcıyı dinlemeye başlar. Kullanıcıdan bir talep geldiği zaman bir backend process başlatılır ve kullanıcıdan gelen tüm talepleri de bu backend process yakalar.Postgres server process default olarak 5432 portu olmak üzere aynı anda yalnızca bir portu dinler. Ancak port numaraları farklı olmak üzere aynı hostta birden fazla PostgreSQL veri tabanı çalıştırmak mümkündür. 2.2. Backend Process Backend process (postgres), postgres server process tarafından başlatılan ve istemciden gelen sorgu ve statement'ları yakalayacan process'tir. Postgres istemciyle tek TCP bağlantısı üzerinden iletişim kurar ve bağlantı kesildiğinde process sonlandırılır. Postgres aynı anda yalnızca bir veri tabanı üzerinde operasyonlar gerçekleştirebildiği için bağlantısı sırasında veri tabanını açıkça belirtmek gereklidir. PostgreSQL'in dahili bağlantı havuzu olmadığı için kısa zamanda sık sık bağlanma/bağlantıyı kesme gibi işlemlerde (web sitesi hizmetleri gibi) backend proces oluşturma maliyeti artacaktır. Bu maliyetin veri tabanı üzerindeki olumsuz etkilerini minimize etmek için pgbouncer ve pgpool-II gibi connection pooling yazılımları önerilir. 2.3. Backgorund Process Her bir background process'in kendine özel fonksiyonu ve işleri vardır. Genel olarak sunucuda arka planda çalışan yönetimsel işleri gerçekleştiren process'lerdir. ps -ef komutu ile işletim sistemi üzerinde çalışan processleri, ps -ef | grep postgres komutu ile komutu ile postgresle ilgli çalışan background processleri görüntüleyebiliriz. Background process'ler logger, checkpointer, background writer, walwriter, autovacuum launcher, stats collector olarak sıralanabilir.Background Writer : Shared buffer pool’da bulunan dirty blokların (değiştirilmiş bloklar) memory’den kalıcı diske yazılması işlemini gerçekleştirir. Checkpointer : Her checkpoint_timeout periodunda ve max_wal_size parametresi aşıldığında checkpoint işlemini gerçekleştirir.Autovacuum Launcher : Vacuum process’inin otomatik olarak belirli zamanlarda başlatılmasından sorumlu process’tir.Wal Writer : Wal bufferda bulunan veriyi wal dosyalarına kalıcı olarak yazmakla sorumludur. Wal dosyaları transaction bilgilerini tutan log dosyalardır. Sistemde ani kapanma durumunda veri kaybı oluşmasını önlemek ve veritabanını recover etmek için kullanılan dosyalardır.Statistic Collector : Verittabanı istatistiklerinin toplanmasını sağlayan processtir.Logger : Hata mesajlarını log dosyalarına yazan processtir.Archiving : Archive.log modundayken WAL dosyasını belirtilen dizine kopyalar.s 3. PostgreSQL Memory Yapıları PostgreSQL'de memory yapıları local ve shared memory area olmak üzere ikiye ayrılır. 3.1. Local Memory Area Her backend processinin kendi kendi kullanımı için açılan memory alanıdır. Kullanıcıdan gelen sorgulama işlemleri sırasında kullanmak için memoryden allocate edilen alandır. Work_mem, maintenance_work_mem ve temp_buffer olmak üzere 3 temel yapıdan oluşur.work_mem : Sorgulama işlemleri sırasında join, order by, distinct gibi ifadeler için kullanılan geçici memory alanıdır.maintenance_work_mem : Reindex, vacuum gibi bakım işlemleri için kullanılan alandır.temp_buffer : Geçici tabloların tutulduğu bellek alanıdır. 3.2. Shared Memory Area Tüm processler tarafından paylaşımlı olarak kullanılan memory alandır.Server başlatıldığında postmaster tarafından memoryden allocate edilen alandır. Bu alanda shared buffer pool, wal buffer ve commit log (CLOG) gibi 3 bileşenden oluşur.shared buffer pool :Daha hızlı okuma yazma işlemi yapılması için verinin tutulduğu memory alanıdır. Veri her seferinde diskten okunup yazılmaz. Bu alanda tutulur ve değiştirilir. Daha sonra background writer devreye girerek değişen blokları data filelara yazar.wal buffer :Veri kaybını önlemek için kullanılan transaction kayıt dosyalarına wal dosyaları denir. Bu kayıtların dosyalara yazılmadan önce memoryde tutulduğu alana denir.CLOGCommit log, tutarlılık kontrolü için transactionların durumunun (in progress, committed, aborted) tutulduğu alandır." }, { "title": "Temel Linux Komutları", "url": "/posts/basic-linux-commands/", "categories": "Not Defteri, Linux", "tags": "linux, os, operating system", "date": "2022-10-20 21:30:30 +0300", "snippet": "Bilgisayarlarımız çalışmak için işletim sistemlerine ihtiyaç duyar. Günümüzde en çok kullanılan işletim sistemleri Windows, MacOS, Linux ve Android işletim sistemleridir. Bu işletim sistemlerinden ...", "content": "Bilgisayarlarımız çalışmak için işletim sistemlerine ihtiyaç duyar. Günümüzde en çok kullanılan işletim sistemleri Windows, MacOS, Linux ve Android işletim sistemleridir. Bu işletim sistemlerinden Linux'un masaüstü bilgisayarlarda pazar payı %2.5 olsa da bulut ve hosting hizmetlerinde bu oran %90 üzerine çıkmaktadır. Dolayısıyla temel linux komutlarını bilmek önem arz etmektedir.Linux 1991 yılında Linus Torvalds tarafından geliştirilen, en çok bilinen ve en çok kullanılan açık kaynak kodlu işletim sistemidir. Linux, açık kaynak kodlu olduğu için, kullanıcılar özgürce kaynak kodunu indirip değiştirme, dağıtma ve paylaşma gibi aktiviteler yapabilirler. Bu nedenle, Linux, dünya çapında birçok kullanıcının ve geliştiricinin kullanması ve katkıda bulunmasıyla hızla gelişir ve güncellenir. Linux, birçok farklı cihazda kullanılabilecek şekilde özelleştirilebilir ve ölçeklenebilir bir işletim sistemi olarak kabul edilir. cat : cat (concatenate) komutu temel olarak bir dosyasının içeriğini görüntülemek için kullanılır. Ayrıca dosya içeriğini filtrelemek ve yeniden yönlendirmek için de kullanılabilir.-- dosyanın içeriğini görüntülemek$ cat file.txt-- dosyaları birleştirmek$ cat file1.txt file2.txt &gt; new_file.txt cd : cd (change directory) komutu linux ve unix tabanlı işletim sistemlerinde farklı dizinler arasında geçiş yapmaya olanak tanıyan komuttur. -- dizin değiştirme$ cd hedefdizin-- bir üst dizine gitme$ cd ..-- ana dizine dönme$ cd chmod : chmod (change mod) komutu dosya veya dizinlerin erişim haklarını değiştirmeye olanak tanıyan komuttur. Dosyalar ve dizinler, üç farklı kullanıcı sınıfı tarafından erişilebilir: kullanıcı (owner), grup ve diğer kullanıcılar. \"chmod\" komutu, bu kullanıcı sınıflarının erişim haklarını değiştirir. Erişim hakları, okuma (r), yazma (w) ve çalıştırma (x) şeklinde belirtilir. chmod komutu, dosya veya dizinlerin erişim haklarını belirlemek için 3 farklı sayı kullanır: 4, 2 ve 1. Bu sayılar, sırasıyla okuma (r), yazma (w) ve çalıştırma (x) haklarını temsil eder. Bu sayılar farklı kombinasyonlar halinde kullanılarak dosyaların ve dizinlerin erişim hakları belirlenir. Örneğin, 7 (rwx) tüm erişim haklarını temsil ederken, 0 (---) tüm erişim haklarını kapatır. -- Erişim haklarını belirli bir sayısal değere değiştirmek$ chmod 755 file.txt chown : chown (change owner) komutu dosya ve dizinlerin sahiplerini değiştirmeye olanak tanıyan komuttur. Linux tabanlı işletim sistemlerinde bir dosyanın sahibi o dosyayı oluşturan kullanıcıdır. chown komutu dosya ve dizinlerin sahiplik bilgilerini deiştirmek için yaygın olarak kulanılan komuttur. -- dosya veya dizinin sahibini değiştirmek$ chown new_user file.txt-- tüm alt dizinler ve dosyaların sahiplik bilgisini değiştirmek$ chown -R new_user:new_group_folder/ cp : cp (copy) komutu dosya ve dizinlerin kopyalanmasında kullanılır. -- bir dosyayı başka bir dosyaya kopyalamak$ cp file1.txt file2.txt-- bir dosyayı başka bir dizine kopyalamak$ cp file.text directory/-- tüm dosya ve dizinleri bir dizine koyalamak$ cp -R source/ target/ df: df (disk free) komutu dosya sisteminin durumu hakkında (özellikle disk kullanımı hakkında) bilgi verir. Komut sayesinde mevcut disk alanının kullanılan ve boş olan kısmını hangi dosya sistemlerinin daha fazla kaynak kullandığı görüntülenebilir. -- okunabilir çıktı için$ df -h diff : diff (difference) komutu iki dosya ve dizin arasındaki farklılıkları gösteren komuttur. Bu komut ile değişen dosya ve satırlar ayıklanarak başka bir dosyaya yazılabilir. -- iki dosya arasındaki fark$ diff file1.txt file2.txt-- iki dizin arasındaki fark$ diff -r dir1/ dir2/-- farkları bir dosyaya kaydetmek$ diff file1.txt file2.txt &gt; difference.txt du : du (disk usage) komutu parametre olarak aldığı dosya sisteminin disk kullanımı hakkında bilgi verir. Parametre olarak bir dizin almazsa mevcut dizinin disk kullanımı hakknında bilgi verir. Bu bilgiler disk kullanımını etkin bir şekilde yönetmek için yardımcı olur.-- belirli bir dizinin disk kullanımını görüntülemek$ du /home/user/directory--okunaklı çıktı almak$ du -h echo : echo komutu terminal ekranına değişken veya değerleri yazdırmak için kullanılan komuttur. -- bir metin yazdırmak$ echo \"Hello world!\"-- bir değişken değeri yazdırmak$ echo $KULLANICI_ADI find : find komutu belirli bir dizin veya alt dizinlerindeki dosya ve dizinleri aramak için kullanılır. Eğer dosya yolu belirtilmezse işlemler mevcut dizinde gerçekleştirilir. -- belirli bir dizinde belirli bir dosya adı ile arama yapmak$ find /home/user/directory -name filename-- boyut kriterli arama yapmak$ find /home/user/directory size +1M-- tarih kriterli arama yapmak$ find /home/user/directory -mtime -7 grep : grep komutu bir metin dosyası ve çıktı akışındaki belirli bir desene göre eşleşen satırları bulmak için kullanılır. -- belirli bir dosyada belirli bir kelimeyi aramak$ grep kelime dosya-- belirli bir dosyada belirli bir desen için düzenli ifade kullanmak$ grep 'desen' dosya-- bir dizindeki tüm dosyalarda belirli bir kelimeyi aramak$ grep -r kelime directory/ head : head komutu bir dosyanın ilk birkaç satırını yazdırmak için kullanılır. -- belirli bir dosyanın ilk 10 satırını yazdırmak$ head file.txt-- belirli bir dosyanın ilk N satırını yazdırmak$ head -n N file.txt history : history komutu ile sisteme daha önce girilen komutlar listelenebilir. Daha önce girilen bir komutu tekrar çalıştırmak için ! işareti kullanmak yeterlidir. -- daha önce girilen son 100 komutu görüntülemek için$ history 100-- geçmişte girilen komutların listesini bir dosyaya kaydetmek için $history &gt; dosya_adı-- geçmişte girilen komutlarda belirli bir kelimeyi aramak için$ history | grep kelime hostname : hostname komutu sistemdeki bilgisayar adını (host adını) görüntülemek ve değiştirmek için kullanılır. hostname komutu kullanıldığında, sistemdeki bilgisayar adı (host adı) ekrana yazdırılır. Varsayılan olarak, bu ad, bilgisayarın ilk kurulum sırasında belirlenen isimdir. -- sistemdeki bilgisayar adını görüntülemek için$ hostname-- sistemdeki bilgisayar adını değiştirmek için $ hostname yeni_bilgisayar_adı jobs : jobs komutu arka planda çalışan işlemleri görüntülemek ve yönetmek için kullanılır. Jobs komutu ile sistemde çalışan işlemler ve işlemlere ilişkin bilgiler ekranda listelenir. -- arka planda çalışan işlemleri listelemek için$ jobs-- bir işlemi durdurmak için $ kill %&lt;işlem numarası&gt;--bir işlemi devam ettirmek için: $ fg %&lt;işlem numarası&gt;-- bir işlemi arka planda devam ettirmek için $ bg %&lt;işlem numarası&gt; kill : kill komutu belirli bir işlemi sonlandırmak veya sinyal göndermek için kullanılır. kill komutu ile bir işlem PID (Process ID) numarası veya işlem adı kullanılarak sonlandırılabilir. Bu komut, özellikle hata veren veya donanım hatası olan işlemleri sonlandırmak için kullanışlıdır. $ kill [options] PID locate : locate komutu belirli bir dosya veya dizinin konumunu hızlıca bulmak için kullanılır. Sıklıkla kullanılan seçenekleri şunlardır: * \"-i\" : Büyük-küçük harf duyarlılığını kapatır. * \"-l\" : Arama sonuçlarının sayısını sınırlandırır. * \"-n\" : Arama yapmak için kullanılacak veritabanını belirler.$ locate [options] filename ls : ls komutu bulunduğunuz dizindeki dosya ve dizinleri listelemek için kullanılır. Kullanımı aşağıdaki gibidir. Burada \"options\", komut için seçeneklerdir ve isteğe bağlıdır. \"file\" ise listelemek istediğiniz dosya veya dizinin adıdır. -- ls komutu temel kullanımı$ ls [options] [file]-- tüm dosya ve dizinleri listeleme$ ls-- tüm dosya ve dizinleri ayrıntılı listeleme$ ls -l-- gizli dosyaları da listeler$ ls -a man : man (manual) komutu kullanıcılara işletim sistemi hakkında detaylı bilgi verir. Kullanımı aşağıdaki gibidir. Burada \"command\", öğrenmek istediğiniz komut veya konunun adıdır. \"section\" ise, komut veya konunun belgelendirme bölümünü belirtir. Örneğin, \"section 1\" komutlar için, \"section 5\" dosya biçimleri için, \"section 8\" sistem yönetimi için kullanılır. \"Section\" belirtilmezse, varsayılan olarak \"section 1\" kullanılır. Örneğin, \"man ls\" komutu \"ls\" komutu hakkında ayrıntılı belgelendirme sağlar. Ayrıca, \"man 5 passwd\" komutu, \"passwd\" dosya biçimi hakkında belgelendirme sağlar.$ man [section] command mkdir : mkdir (make directory) komutu kullanıcıların dizin veya klasör oluşturmasına olanak tanır. -- doc dizini oluşturma$ mkdir doc-- doc dizini altına project dizini oluşturma$ mkdir doc/project-- iki işlemi tek adımda yapma$ mkdir -p doc/project mv : mv (move) komutu dosyaları veya dizinleri taşımak veya yeniden adlandırmak için kullanılır. -- bir dosyayı başka bir dizine taşıma$ mv file.txt Documents/ ping : ping komutu bilgisayar ağları üzerindeki diğer cihazların bağlantısını test etmek için kullanılan bir araçtır. Bu komut, bir IP adresi veya bir ana bilgisayar adı belirtilerek kullanılır ve ağdaki bir cihaza bir paket gönderir ve o cihazdan bir yanıt alınmasını bekler. $ ping [options] host pwd : pwd (print working directory) komutu, çalışılan dizinin tam yolunu ekrana yazdırmak için kullanılan bir komuttur. Özellikle uzun ve karmaşık bir dizin yapısı içinde çalışırken, mevcut dizinin tam yolunu hızlı bir şekilde görüntülemek için kullanışlı bir araçtır. rm : rm (remove) komutu, dosya veya dizinleri silmek için kullanılır. -- bir dosya silmek$ rm myFile.txt-- bir dizin silmek$ rm -r directory rmdir : rmdir (remove directory) komutu dizinleri silmek için kullanılır. Bu komut sadece boş dizinleri silebilir. Eğer dizin içinde dosya veya alt dizin varsa, \"rmdir\" komutu çalışmayacaktır.$ rmdir directory tail : tail komutu bir dosyanın son kısmını görüntülemek için kullanılan bir komuttur. Bu komutla, bir dosyanın en son satırları veya belirli bir sayıda son satırı görüntülenebilir. Genelde büyük dosyaların sonunda meydana gelen hataları veya değişiklikleri izlemek için kullanılır. $ tail [options] filename tar : tar (Tape Archive) komutu bir arşivleme aracıdır. Bu komut, birden çok dosya veya dizini tek bir arşiv dosyasında toplamanıza ve sıkıştırmanıza olanak tanır. Bazı yaygın \"tar\" komutu kullanımları şunlardır:-- Arşiv dosyası oluşturma$ tar -cvf archive.tar file1 file2 dir1-- Arşiv dosyasından dosyaların geri çekilmesi$ tar -xvf archive.tar-- Arşiv dosyasının sıkıştırılması (gzip)$ tar -czvf archive.tar.gz file1 file2 dir1-- Sıkıştırılmış bir arşiv dosyasından dosyaların geri çekilmesi$ tar -xzvf archive.tar.gz top : top komutu sistem performansı ve kaynak kullanımı hakkında gerçek zamanlı bilgi sağlayan bir araçtır. Bu komut, işlemci kullanımı, bellek kullanımı, disk girdi/çıktısı kullanımı, işlem öncelikleri, CPU sürelerini ve diğer birçok sistem ölçütlerini izleyebilir. Ayrıca sistem kaynaklarının kullanımını öncelik sırasına göre sıralayarak hangi işlemlerin sistemde en fazla kaynak kullandığını da görüntüleyebilir. touch : touch komutu var olan dosyaların erişim veya değiştirilme zamanlarını güncellemek veya var olmayan dosyaları oluşturmak için kullanılan bir komuttur.$ touch [option(s)] file_name(s) unzip : unzip komutu sıkıştırılmış ZIP dosyalarını açmak için kullanılan bir komuttur.$ unzip -q data.zip zip : zip komutu bir veya daha fazla dosyayı sıkıştırmak veya arşivlemek için kullanılan bir Linux komutudur. $ zip [options] archive file(s)..." }, { "title": "Versiyon Kontrol Sistemleri - Git ve Github", "url": "/posts/git_and_github/", "categories": "Not Defteri, Git", "tags": "git, github", "date": "2022-08-01 21:30:30 +0300", "snippet": " Giriş Yazılım geliştiricilerin ve şirketlerin vazgeçilmez araçlarından biri versiyon kontrol sistemleridir. Versiyon kontrol sistemleri bir dosya ya da dosya kümesindeki değişiklerin takip edilmes...", "content": " Giriş Yazılım geliştiricilerin ve şirketlerin vazgeçilmez araçlarından biri versiyon kontrol sistemleridir. Versiyon kontrol sistemleri bir dosya ya da dosya kümesindeki değişiklerin takip edilmesine olanak sağlar. Aynı zamanda ekip çalışmasını da mümkün kılar. Versiyon kontrol sistemleri ile çalışırken versiyonlar arası geçiş yapabilir, projeyi farklı dallara (branch diyeceğiz) ayırarak kendimize test alanları oluşturabiliriz.2005 yılında kendi geliştirmelerini yaparken farklı alternatifler olsa da açık kaynak kodlu bir versiyon kontrol sistemi eksikliğini hisseden Linus Torvalds Git'i geliştirmeye başladı. Arkasına açık kaynak kod topluluğunun gücünü de alan Git, sektörün en popüler versiyon kontrol sistemlerinden biri oldu.Git çalışma mantığı oyunlardaki 'checkpoint' kavramı gibidir. Bir proje geliştirirken tamamlanan bölümleri loglayabilir bu şekilde proje geliştirme safhasını adım adım ele alabiliriz. Ayrıca hangi gün ne gibi değişiklikler yapıldığını görebilir gerektiği takdirde bu değişiklikleri geri alabiliriz.Çoğunlukla git ile karıştırılan github ise basit anlamda git repolarımızı sakladığımız bir portal diyebiliriz. Endüstrinin çok büyük bir bölümünde bu iki sistem kullanılsa da bu iki sistemi iyi bir şekilde öğrendikten sonra diğer versiyon kontrol sistemlerine geçmekte kolay olacaktır. Git Temelleri Git ile proje dizinindeki değişiklikler izleneceğinden ilgili proje için yeni bir klasör oluşturulur. Oluşturulan klasördeki değişikliklerin algılanıp takip edilebilmesi için klasörün Git'e tanıtılması gerekmektedir.Bu noktada iki önemli komut (status ve init) karşımıza çıkar. Status komutu ile mevcut repodaki durumu (izlenen ve izlenmeyen dosyalar, değişiklikler gibi) çıktı olarak alabiliriz. Ancak klasör bir git reposu olmayabilir. Bu durumda init komutu ile klasörü Git'e tanıtarak bir git reposu haline getirebiliriz. Ancak henüz klasördeki değişiklikler izlenir durumda değildir. $ git status-- klasördeki mevcut durum$ git init-- klasörü git reposu haline getirir.Herhangi bir klasörde init komutu çalıştırmadan önce status komutunu çalıştırarak güncel durumunu kontrol etmemiz gerekir. Git initi tekrar tekrar çalıştırmak karışıklığa sebep olabilir. Git init komutu çalıştığında mevcut klasörde .git isimli gizli bir klasör oluşur. Eğer yanlışlıkla bir klasörde git init komutu çalıştırılırsa bu klasörü silerek git ile bağlantısını kaldırmış oluruz. Git Branch Takım çalışmasını tesis etmek ve yönetimi kolaylaştırmak için proje branch'lere bölünebilir. Yani bir proje tek bir branch'ten oluşabileceği gibi birden fazla branch'ten de oluşabilir. Farklı branchlerdeki değişiklikler optimum şekilde çalışmaya başladığında ana branch ile birleştirilebilir. -- projeye yeni branch eklemek$ git branch branchname İlk Commit Git'e tanıttığımız klasöre yeni dosyalar eklemeye başladığımızda 'git status' komutunun çıktıları değişecektir. Bu dosyalar yeni eklendiği ve sisteme 'izle' komutu verilmediği için untracked olarak kabul edilir. Dosyalardaki değişikleri ya da klasörün tamamındaki değişiklikleri takip etmek için aşağıdaki komutlar çalıştırılır.$ git add dosyaadi -- verilen dosyayı indeksler$ git add . -- tüm dosyaları indekslerBu komutlardan sonra sistem dosyaları izlemeye başladı ancak henüz commit edilmedi, sadece indekslendi. Aşağıdaki komutla değişikliklerimizi commitleyerek değişiklikleri onaylayabiliriz. Commit mesajlarının kısa ve açıklayıcı olmasına özen gösterilmelidir.Commitlenen dosyalar, commit zamanı, commit işlemini yapan kişiye ait bilgiler loglanır. Bu loglamaya ilerleyen dönemlerde ihtiyaç halinde ulaşılabilir. git log komutu ile commitlere ait loglara erişebiliriz. Eğer tek bir satırda hem git add hem de commit işlemi yapmak istersek commit yaparken -a argümanını kullanabiliriz.-- değişikliklerin commitlenmesi$ git commit -m “commit mesajı”-- loglara ulaşmak$ git log-- tek satırda git add ve git commit komutu$ git commit -a \"commit mesajı\" Gitignore Git ile izlenen klasördeki tüm dosyalar indekslenip github'a yüklenebilir. Ancak bazı özel dosyaları bu durumdan muaf tutmak gerekebilir. Bunu sağlamak için gitignore dosyası oluşturulur. Çalışılan klasörde oluşturulacak ve içine özel dosyalar yazılan .gitignore dosyası ile özel bilgi ve belgeler indekslenmeyecek, repoya eklenmeyecektir. Github’da gitignore reposu altında programlama dillerine özel gitignore şablonları vardır. Projeyi internete atmadan önce bu listeler incelenerek faydalanılabilir. Head Bir repodaki ana branch projenin hazır halidir. Yani tamamlanan değişiklikler ana branchte tutulur. HEAD ise projede aktif olarak hangi branch ve hangi commitle olduğumuzu işaretleyen bir ifadedir. Yeni branchler açıldıkça ve yeni commitler geldikçe HEAD ifadesinin işaretlediği yer de değişir. Merge Proje ana branchi master branchtir. Daha sonra test ortamı ya da yeni özellikler eklemek için yeni bir branch açıp oradaki çalışmalar tamamlandıktan sonra bu iki branchi (daha fazla da olabilir) birleştirme ihtiyacı doğabilir. Bu durumda HEAD yeni açılan branchi işaretleyecektir. Tekrar master branche dönmek için switch komutu çalıştırılmalıdır. Bu iki branchte yapılan değişiklikleri birleştirmek için merge komutu kullanılır. Aşağıdaki komut ile master branchin üzerine sonradan açılan branch eklenir ve birleştirme işlemi tamamlanır. git branch komutu çalıştırıldığında güncel branch listesi ekrana basılır.-- Merge komutu$ git merge branchname \"commit mesajı\"-- Branch değiştirme$ git switch branchname-- Branch listesi$ git branch Fast Forward Yeni bir branch açarak çalışıldığında değişiklikler aynı noktalarda yapılabilir. Bu durumda merge işlemi aşamasında conflict problemi ile karşılaşabiliriz. Bu durum genellikle hem master hem de yan branchlerde değişiklik yapıldığında karşılaşılabilir. Bunun önüne geçmek için masterda hiç değişiklik yapmadan tüm değişikliklerin yan branchte yapılıp daha sonradan birleştirme yoluna gidilebilir. Bu işleme fast forwarding denir. Merge Conflict Farklı branchlerde yapılan ve birbirini etkileyen işlemler merge conflict hatasına sebep olabilir. Bu durumlarda merge işlemi otomatik olarak gerçekleştirilmez. Meydana gelen çakışmaların çözülmesi ve ondan sonra merge işleminin yapılması gereklidir. Kalacak ve gidecek dosyalar tespit edilir ve daha sonra merge ve commit işlemi tekrar yapılarak bu sorun da çözülmüş olur. Stash Kavramı Bir branchte yapılan değişikliklerin commitlenememesi ve branchin değişmesi durumunda farklı problemler ortaya çıkabilir. Proje, restore komutu ile son commit durumuna geri döndürülebilir ancak bu da veri kaybı demektir. Proje commitlemeye müsaitse commit edilmeli aksi durumda restore ve stash kavramları değerlendirilmelidir..-- son commite dönme$ git restore filenameStash yaparak değişiklikleri commitlemeden de saklayıp daha sonradan dönebiliriz. Değişiklik yapıldıktan sonra commitleyecek durumda değilsek stash komutu ile yapılan değişiklikler saklanır. Değişiklikleri sakladığımız yerden almak için stash pop komutu çalıştırılır. Gerekli düzenlemeler tamamlandıktan sonra commitlenebilir.git stash list komutu ile güncel stashleri listeleriz. Birden fazla stash varsa git stash apply stash@{0} komutu ile stash listesinden istediğimiz stashi geri getirebiliriz. Bu şekilde istediğimiz stashi istediğimiz yere commitleyebiliriz. Git stash clear komutu ile stash listesini temizleyebiliriz. git stash apply komutu ile de mevcut stash’in tuttuğu değişiklikler geri getirilir ama stash listesinde de kalmaya devam eder. Pop ile geri getirilen değişiklikler stash listesinden çıkarılır. Geçmişe Dönme Commit atmadığımız değişiklikler için git restore komutu ile değişikliklerden vazgeçebiliriz. Ama commitledikten sonra tekrar geri dönmek gerekirse checkout komutu kullanılır..$ git checkout commitIDAncak bu noktada bir problem ortaya çıkar. HEAD kısmı güncel commiti gösterir ama master son commiti gördüğü için HEAD’i görmez. Bu hatadan kaçınmak için git switch master ile master branche geri dönebiliriz. Ama bu bizi geri döndürür yani değişiklik yapmamış oluruz.Peki aynı branchten devam etmek için ne yapmalıyız? git reset commitID ile verilen commit ID’den sonraki commitler silinir ancak o commitlerin değişiklikleri kalır. git reset --hard commitID komutu ile verilen commitID’den sonraki commitleri ve yapılan değişiklerin hepsini siler. Ancak dikkatli olunmalıdır, özellikle birden fazla kişi ile çalışırken conflicte sebep olabilir. Son iki commiti sileyim ama yeni bir commit oluşturayım bir de masterdan devam edeyim dersek o zaman revert komutunu kullanacağız. git revert commitID şekliyle yaralanıyoruz. Ancak bunları yaparken dikkat etmeliyiz çünkü conflict meydana gelebilir. Git Diff Git diff komutu ile belli başlı yerler arasındaki farkları gösterir. Bunlar dosyalar ve kodlar arasındaki farklar olabilir. Yapılan değişiklikleri, silinenleri ve eklenenleri gösterir. Git diff tek başına çalıştırıldığında sadece güncel dosya içerisinde yapılan değişikleri gösterir. İndekslenen dosyadaki değişiklikleri göstermez. Ama biz herhangi bir şey için de değişiklikleri de görebiliriz. Mesela git diff HEAD çalıştırıp son commite göre neleri değiştirdiğimizi de görebiliriz (Bunun sebebi HEAD’in son commite işaret etmesi). Commitler arasındaki farkı görmek için ise git diff commit1 commit2 yazarsak iki commit arasındaki farkı gösterir.İki commit arasındaki boşluk açısından bir problem olursa iki nokta koyabiliriz. Aynı şekilde iki branch arasındaki değişiklikleri de görebiliriz. Rebase Git’in en çok korkulan konularından biridir çünkü yanlış kullanılırsa sorunlara sebep olabilir. Ana proje master branchinde tutuluyor olsun. Başka bir branch ile çalışmalarımıza devam edip tamamladıktan sonra merge edebiliriz. Ve bu durum devam ederse bir çok merge commit oluşur. git switch feat ve ardından git rebase master komutları ile rebase yapılabilir ve bu şekilde commitler sıralanarak loglanabilir. Bu şekilde bir uygulamada tarih değiştiği için özellikle takım çalışmalarında problem yaratabilir. Bireysel çalışmalarda kullanmaya daha uygundur.Rebase ile merge commitleri temizleyip önce master commitleri sonra yeni branch commitleri sıralanır ve loglar temizlenmiş olur. Github Git popüler bir versiyon kontrol sistemidir ve faydaları saymakla bitmez. Git’in yol arkadaşı local repolarımızı online ortama taşıyabildiğimiz ücretli ve ücretsiz versiyonları bulunan Github’dır. Github ile projelerimizi public ya da private olarak saklayabilir, takım çalışmalarına katılabilir ve başka projelere katkıda bulunabiliriz. Bu işlemleri yapmak için de clone ve fork kavramlarını bilmek gereklidir. İlk Repository Github internet sitesinde yeni bir repo oluşturulur. Oluşturulan repoya ait bilgiler açılış ekranında verilir. -- remote repo ekleme$ git remote add origin repoUrl-- uzak repoya değişiklikleri gönderme$ git push -u origin main -- uzak repodaki branchleri görüntüleme$ git branch -r-- uzak repodaki branche geçme$ git checkout origin/mainÖzellikle farklı bilgisayarlar ile çalışırken repoların senkronize olmama durumu ile karşılaşabiliriz. Bu durumda repoları senkronize etmek için fetch ve pull komutları kullanılır. -- origin linkindeki master branchı getirme$ git fetch origin masterFetch komutu dosyaları bize getirir ama bizim dosyalarımızı değiştirmez. Bize değişiklikleri inceleme imkanı sunar. İncelemeden sonra bir problem olmadığı anlaşılırsa pull komutu ile dosyalardaki değişiklikleri onaylayabiliriz.-- origin linkindeki değişiklikleri onaylama$ git pull origin master Clone ve Fork Github ile paylaşılmış bir repoyu siteden indirebileceğimiz gibi, git ile de bir repo dosyası olarak indirebiliriz.-- Clone$ git clone repoUrl Bu komut verilen adresteki dosyaları mevcut dizine indirecektir. Bu dosyalardan çalışmaya devam edebiliriz. Ancak uzaktaki bir projeye katkı sağlama düşüncesi varsa yani bu dosyalardaki değişiklikleri proje sahibine göndererek çalışmaya katkı vermeyi amaçlıyorsak o zaman projeyi forklamak gereklidir. Projeyi forkladıktan sonra local repo oluşturarak klonlayıp kendi değişikliklerimizi yapabilir incelemesi için tekrar proje sahibine (pull requests açmak) gönderebiliriz. NOT: Bu yazının hazırlanmasında Atıl Samancıoğlu hocamın BTK Akademi platformundaki Versiyon Kontrol Sistemleri kursundan yararlanılmıştır. Kendisine teşekkür ederim. " }, { "title": "Etkin Mekansal Veri Yönetim Aracı - PostGIS", "url": "/posts/postgis_extension/", "categories": "PostgreSQL, PostGIS", "tags": "postgresql, postgis, spatial database, gis", "date": "2022-05-15 21:30:30 +0300", "snippet": " 1. Giriş Bilgi ve iletişim teknolojilerinde yaşanmakta olan değişim ve dönüşüm her geçen gün hızını artırmakta ve insan hayatının neredeyse her alanına etki etmektedir. Yaşanan teknolojik gelişmel...", "content": " 1. Giriş Bilgi ve iletişim teknolojilerinde yaşanmakta olan değişim ve dönüşüm her geçen gün hızını artırmakta ve insan hayatının neredeyse her alanına etki etmektedir. Yaşanan teknolojik gelişmeler sonucunda meydana gelen yeni ürün ve yöntemler ile insanlar yeni tecrübeler edinmekte ya da var olan deneyimlerini iyileştirmektedir. Teknolojinin getirdiği bu yenilikler sonucunda veri kaynakları artmış, yeni depolama yöntemleri ve analiz araçları geliştirilmiştir.Veri, en genel anlamda bir amaç doğrultusunda sistematik olarak toplanan her türlü harf, rakam ya da ‘değer’ler topluluğu olarak tanımlanabilir. Veri üretilirken ilgili amaç doğrultusunda “Ne?” sorusunda yanıt aranır. Bununla birlikte herhangi bir nesne ya da olgunun coğrafi konumunu ifade etmek için kullanılan veriye ise konumsal veri denir [1]. Günümüzde çeşitli kaynaklardan üretilen verinin çok büyük bir bölümünün konuma dayalı olduğu düşünüldüğünde bu verinin depolanması ve analizi büyük önem arz etmektedir.Üretilen verinin kullanılabilmesi ve fayda sağlaması için işlenerek bilgiye dönüştürülmesi gerekmektedir. Bu sebeple veri, bilginin ham maddesi olarak da tanımlanabilir. Veriyi gerektiğinde çağırarak faydalı bilgi üretmek ve etkili bir biçimde kullanmak için ise etkin bir şekilde depolamak gereklidir.Teknolojinin erken dönemlerinde defterler ve dosyalarda saklanan veriler bilgisayarların insan hayatına girmesiyle birlikte dijital ortamda saklanmaya başlanmış ve gelişen teknoloji ile farklı veri depolama yaklaşımları geliştirilmiştir. Bu yaklaşımlardan en popüler olanı 1970 yılında E. F. Codd tarafından açıklanan ilişkisel veri tabanı modelidir. Bu model ile güçlü, tutarlı ve veri tekrarını engelleyecek şekilde veri tabanı yapıları oluşturulmuştur [2]. Sağladığı bu avantajlar sebebiyle popüler olmuş ve verinin hayati önem taşıdığı uygulamalarda (bankacılık sistemleri gibi) kullanılmış ve hala da kullanılmaktadır.Yaşanan gelişmeler doğrultusunda mevcut ve geliştirilmekte olan veri tabanı yönetim sistemleri de yeni özellikleri sistemlerine entegre ederek sürece dahil olmuştur. Günümüzde oldukça popüler olan, hızlı ve yüksek güvenlikli bir ilişkisel veri tabanı yönetim sistemi olan PostgreSQL’in gelişim sürecine bakıldığında ortaya çıkışı 1977 yılına kadar dayanmaktadır. PostgreSQL arkasında büyük bir açık kaynak kod geliştirme topluluğu bulunan, SQL standartlarını ve ilişkisel veri tabanı modelini destekleyen, hızlı, güçlü ve yüksek güvenlikli bir veri tabanı yönetim sistemidir [3]. Ticari yazılımların hemen hemen tüm özelliklerini destekleyen ve aynı zamanda kendine has özellikler içeren bir sistemdir [2]. Mekansal veri yönetimi için oldukça güçlü bir çözüm sunan PostGIS eklentisi ile mekansal veriyi destekleyen ilk veri tabanı yönetim sistemlerinden biri olmuştur [4]. PostGIS, binden fazla mekansal fonksiyonu bulunan en verimli açık kaynak kodlu mekansal veri yönetim aracıdır [5]. Çeşitli GIS yazılımları (QGIS, ArcGIS vb.) ile de entegre bir şekilde kullanılabilmektedir ve açık kaynak kodlu olduğu için gelişime açıktır. PostgreSQL kurulumundan sonra basit bir prosedür izlenerek sunucuya dahil edilen PostGIS istenilen veri tabanına basit bir SQL cümlesiyle eklenir. PostGIS eklentisinin eklenmesi ile PostgreSQL’in temel veri tipleri ve fonksiyonları genişletilerek mekansal veri tipleri ve mekansal fonksiyonlar kullanılabilir duruma getirilir. Vektör ve raster veri desteği bulunan PostGIS’te koordinat dönüşümü, uzunluk ve alan hesaplamaları, mekansal ilişkilerin sınanması gibi birçok işlem kolay ve hızlı bir şekilde gerçekleştirilebilir.Bu yazıda PostGIS kurulumundan başlanarak örnek bir vektör veri seti üzerinde kullanışlı PostGIS fonksiyonları aktarılarak kullanım örneklerine yer verilecektir. 2. PostGIS Kurulumu PostGIS kurulumundan önce bilgisayarda PostgreSQL kurulu olmalıdır. Eğer kurulu değilse postgresql.org adresinden kullanılacak bilgisayarın işletim sistemine uygun sürüm indirilerek temel kurulum adımları izlenerek kurulum yapılabilir. Daha sonra lokal sunucuya erişmek için kullanılacak olan master kullanıcı parolası kurulum adımında belirlenir ve unutulmamalıdır. PostgreSQL kurulumu tamamlandıktan sonra PostGIS eklentisini sunucuya dahil etmek için farklı bir prosedür izlenmektedir. PostgreSQL sunucusuna ek seçenek ve eklenti kurulmasına olanak tanıyan ve PostgreSQL kurulumu ile birlikte gelen Stack Builder uygulaması ile PostGIS eklentisi sunucuya kurulabilir. Aşağıdaki kurulum adımları izlenerek PostGIS eklentisi sunucuya dahil edilebilir [6].1. PostgreSQL kurulumu ile birlikte gelen Stack Builder uygulaması çalıştırılır ve yapılandırmak istenilen sunucu seçilerek \"Sonraki\" butonu ile bir sonraki adıma geçilir.2. Uygulama listesi okunduktan sonra gelen ekranda kategorize edilmiş şekilde sunucuya eklenebilecek özellikler yer almaktadır. “Spatial Extensions” kategorisi altına gidilerek ilgili PostGIS sürümünü seçip \"Sonraki\" butonu ile bir sonraki adıma geçilir. 3. Seçilen paketleri gözden geçirme ekranı gelecektir. Bu ekranda \"Sonraki\" butonuna tıklanarak temel kurulum adımlarına geçilir. Bu aşamada önerilen ayarları izleyerek PostGIS eklentisi sunucuya dahil edilebilir.4. PostGIS eklentisi sunucuya dahil edilse de eklenti ile birlikte gelen veri tipi ve fonksiyonları kullanabilmek için ilgili veri tabanında da eklentiyi kurmak gereklidir. Bu işlemi aşağıdaki komutu bir kere çalıştırarak gerçekleştirebilir PostGIS fonksiyonlarını kullanmaya başlayabiliriz.CREATE EXTENSION postgis; 5.\tKurulum sorunsuz bir şekilde tamamlandıktan sonra test etmek adına aşağıdaki komut çalıştırılabilir. Bu komut PostGIS fonksiyonlarından biridir ve kullanılan sürüm hakkında bilgi mesajı döndürür.SELECT postgis_verison();-- Çıktı: \"3.0 USE_GEOS=1 USE_PROJ=1 USE_STATS=1\"-- postgis_full_version() fonksiyonu ile daha detaylı bilgi alınabilir.Kullanılan PostGIS sürümüne ait bilgiler sorunsuz şekilde ekrana yazıldığı takdirde kurulum tamamlanmış, kullanıma hazırdır. 3. Mekansal Veri Ekleme PostGIS kurulumu sorunsuz bir şekilde tamamlandıktan sonra yeni bir veri tabanı oluşturarak örnek mekansal veri setini yükleyebiliriz. Bu yazıda https://postgis.net/workshops/postgis-intro/ adresindeki New York şehrine ait örnek veri seti kullanılarak uygulamalar gerçekleştirilecektir. Aynı zamanda kurulum ve veri seti hakkında daha detaylı bilgiye bu sayfadan erişilebilir. Öncelikle “nyc” isimli bir veri tabanı oluşturalım ve PostGIS eklentisini bu veri tabanına dahil edelim.CREATE DATABASE nyc;CREATE EXTENSION postgis; PosgreSQL veri tabanına mekansal veri eklemenin farklı yolları vardır. Çeşitli CBS yazılımları ya da kütüphaneleri ile bu işlem gerçekleştirilebilir. Ancak PostGIS’in bu konuda sağlamış olduğu basit bir Loader uygulaması vardır. *.shp ve *.dbf uzantılı mekansal verileri import etmekte ya da veri tabanında bulunan mekansal verileri export emekte kullanımı kolay bir çözüm sunar.Kurulum ile birlikte gelen PostGIS Loader uygulaması çalıştırılır ve ana ekranda bulunan “View Connection Details” butonuna tıklanarak açılan ekranda gerekli bilgiler doldurulur. Bu bilgiler doğrultusunda uygulama verilerin ekleneceği veri tabanı ile bağlantı yapacaktır.Daha sonra “Add File” butonu ile veri tabanına eklenecek olan *.shp uzantılı dosyalar seçilerek SRID değerleri ayarlanır. SRID değeri veri setinin koordinat sistemini ve sisteme ait parametreleri ifade eden bir kod olarak düşünülebilir. Bu kavram ile ilgili daha detaylı bilgiye ilerleyen bölümlerde değinilecektir. Kullanılacak veri seti için SRID değeri 26918 olarak girilmelidir. Son olarak \"Import\" butonuna tıklanır ve dosyalar bağlantı yapılan veri tabanına tablo olarak eklenir. 4. Koordinat Sistemleri ve SRID Kavramı Koordinat referans sistemleri, konumsal bilgilerin uzayda tek anlamlı bir şekilde ifade edilebilmesi için gerekli olan sabit katsayılar ve parametreleri tanımlar. Konumsal verinin anlam ifade edebilmesi ve analizlerde kullanılabilmesi için oldukça önemli bir kavramdır. Koordinat referans sistemlerinin tanımlanması için farklı sabitler ve parametreler kullanıldığndan standart bir koordinat tanımlama dili oluşturmak adına EPSG (European Petroleum Survey Group) kodları kullanılmaktadır. Bu şekilde hem ifade kolaylığı sağlanmış hem de ortak bir dil oluşturulmuştur. EPSG kodu PostGIS eklentisinde SRID olarak düşünülebilir.Dünyanın şeklinden kaynaklı olarak haritalama işlemlerinde bozulmalar meydana gelmektedir. Bu bozulmalar koordinat sisteminin merkezinde en az olmak üzere kenarlara doğru gidildikçe artmaktadır. Dolayısıyla lokal çalışmalarda o bölgeyi en iyi ifade eden, en az bozulmaya sebep olan koordinat sistemi kullanılmaktadır. Tanımlı birçok koordinat sistemi bulunmakla birlikte PostGIS içerisinde gelen “spatial_ref_sys” tablosunda 8500 adet koordinat sistemi bulunmaktadır. Ülkelerde kullanılan koordinat sistemleri ve tanımlı koordinat sistemlerinin parametrelerine epsg.io adresinden ulaşılabilir.Konumsal analizlerin anlamlı bir sonuç verebilmesi için veri setlerinin aynı koordinat sisteminde olması gerekmektedir. Verilerin çeşitli kaynaklardan temin edildiği göz önüne alındığında analiz yapmadan önce koordinat dönüşümü yapmak gerekebilir. PostGIS eklentisi ile birlikte gelen fonksionlar ile koordinat dönüşümü ve koordinat tanımı değiştirme gibi işlemler basit SQL sorguları ile gerçekleştirilebilmektedir. 4.1. ST_SRID(geom) Mekansal veri tabanındaki geometri sütununu girdi olarak alan bu fonksiyon tablodaki her kayıt için bir tam sayı döndürür. Bu tam sayı koordinat sistemi id’sini (EPSG kodu ya da SRID) ifade eder [9].-- Örnek Kullanım:SELECT ST_SRID(geom) FROM nyc_homicides; -- Çıktı: 26918 (Her kayıt için)Bir tablodaki bütün kayıtların aynı SRID değerine sahip olması beklenir. Her kayıt için dönen bu sonuç ST_SRID komutu ile DISTINCT cümleciği birlikte kullanılarak tek satıra indirgenebilir.-- Örnek Kullanım: SELECT DISTINCT(ST_SRID(geom)) FROM nyc_homicides;-- Çıktı: 26918Benzer şekilde Find_SRID fonksiyonu kullanılarak bu sonuca ulaşılabilir. Tablonun bulunduğu şemayı, tablo adını ve geometri kolonunu girdi olarak alan bu fonksiyon çıktı olarak bir tam sayı verir ve bu tam sayı SRID değerini ifade eder [9].-- Örnek Kullanım:SELECT Find_SRID(‘public’,’nyc_homicides’,’geom’);-- Çıktı: 26918 4.2. ST_SetSRID(geom,srid) ST_SetSRID fonksiyonu bir geometrideki SRID değerini yani koordinat sistemini ifade eden kodu belirli bir tamsayı değerine atamak için kullanılır. __Bu fonksionun koordinat dönüşümü işlemini gerçekleştirmediğine, sadece koordinat sisteminin tanımını değiştirdiğine dikkat edilmelidir.__ Bu fonksiyonun kullanılmasıyla geometrinin içinde olduğu varsayılan koordinat sistemini tanımlayan meta verileri değiştirdiğine dikkat edilmelidir [9].Paramatre olarak bir geometri sütunu ve koordinat sistemini ifade eden bir SRID değeri alır. Koordinat sistemi tanımı değiştirilmiş yeni geometrileri çıktı olarak döndürür.-- Örnek Kullanım: SELECT ST_SRID(ST_SETSRID(geom, 4326)) FROM nyc_homicides;-- Çıktı: 4326ST_SetSRID fonksiyonu koordinat tanımını değiştirse de tabloda güncelleme yapmamaktadır. UpdateGeometrySRID fonksiyonu ile koordinat tanımını değiştirerek aynı zamanda tabloda da güncellenmesini sağlayabiliriz [9].Tablo adı, geometri kolonu ismi ve hedef SRID değerini girdi olarak alan bu fonksiyon çıktı olarak değişimin başarılı olduğuna dair mesaj üretmektedir.-- Örnek Kullanım:SELECT UpdateGeometrySRID('nyc_homicides', 'geom', 4326);--Çıktı: public.nyc_homicides.geom SRID changed to 4326 4.3. ST_Transform(geom, srid) Bir geometrinin koordinatlarını bir koordinat sisteminden başka bir koordinat sistemine dönüştüren fonksiyondur. Genellikle ST_SRID fonksiyonu ile karıştırılsa da bu fonksyion doğrudan koordinat dönüşümü yapmaktadır. Girdi olarak geometri sütununu ve hedef koordinat sisteminin SRID değerini alan fonksyion çıktı olarak koordinatları dönüştürülmüş yeni bir geometri sütunu döndürür [9].-- Örnek Kullanım:SELECT ST_SRID(ST_Transform(geom, 4326)) FROM nyc_homicides;-- Çıktı: 4326 5. Geometri Doğrulama Veri tabanına eklenen ya da çeşitli fonksiyonlarla veri tabanında oluşturulan geometri verilerinde topolojik hatalar olabilir. Geometri verilerinde meydana gelen bu hatalar kullanılacak diğer fonksiyonların çalışmasını engelleyebilir ya da yanlış çalışmasına sebep olabilir. Geometri doğrulama fonksiyonları ile ilgili geometri verilerinin OGC SFS standartlarına göre geçerli olup olmadığı test edilebilir ve hatalar giderilebilir. Eğer varsa hatalar hakkında detaylı bilgi alınabilir. 5.1. ST_IsValid(geom) Parametre olarak verilen geometri verisinin geçerliliğini test eder ve geriye boolean değer döndürür [9].-- Örnek Kullanım: SELECT ST_Isvalid(geom) FROM nyc_homicides;/*Çıktı:True...*/ST_Isvalid fonksiyonu ile geçersiz olan geometri verileri için false değer dönecektir. Geçersiz geometrilerin neden geçerli olmadığı hakkında bilgi almak için fonksiyon ST_IsvalidDetail fonksiyonu kullanılmalıdır [9].-- Örnek Kullanım:SELECT ST_IsvalidDetail(geom) FROM nyc_homicides;/*Çıktı:True...*/Benzer şekilde çalışan bir başka fonksiyon ise ST_IsvalidReason fonksiyonudur. Girdi olarak geometri verisi alır ve text döndürür. Sonuç geçerli ise “Geçerli geometri” mesajı, değil ise neden geçerli olmadığını belirten bir mesaj döndürür [9].-- Örnek Kullanım:SELECT ST_IsvalidReason(geom) FROM nyc_homicides;/*Çıktı:Valid Geometry...*/ 5.2. ST_MakeValid(geom) ST_MakeValid fonksiyonu, geçersiz bir geometri verisi için köşe noktalarından herhangi birini kaybetmeden OGC standartlarına göre geçerli bir temsilini oluşturur. Geçerli geometriler üzerinde herhangi bir değişiklik yapılmadan aynı şekilde geri döndürülür [9].-- Örnek Kullanım:SELECT ST_MakeValid (geom) FROM nyc_homicides;-- Çıktı: Düzeltilmiş PostGIS geometrisi 6. Geometri Girişi Fonksiyonları PostGIS fonksiyonları içerinde çeşitli format ya da metinsel ifadeler kullanılarak veri tabanına geometri girişini sağlayan fonksiyonlar vardır. Bunlardan başlıcaları ST_GeomFromText, ST_GeomFromGeojson, ST_GeomFromGML ve ST_GeomFromKML fonksiyonları olarak sıralanabilir. 6.1. ST_GeomFromText(WKT, srid) OGC WKT temsili olan metinsel bir ifadeden geometri oluşturan fonksiyondur. Eğer SRID değeri parametre olarak verilmezse varsayılan olarak 0 değeri atanır. Bu durum sorgulama esnasında hataya sebep olacağından doğru kullanım veri girişi esnasında SRID değerini de girerek koordinat sistemini doğru şekilde tanımlamak olacaktır [9].-- Örnek Kullanım:SELECT ST_GeomFromText('LINESTRING(-71.160281 42.258729,-71.160837 42.259113,-71.161144 42.25932)',4269); Metin verisinden geometri oluşturan fonksiyon olduğu gibi geometri verisini metinsel olarak export eden fonksiyon da vardır. ST_AsText fonksiyonu ile geometri verisini geometri türü (nokta, çizgi, poligon) ve koordinatlar olacak şekilde metinsel olarak çıktı alabiliriz. 6.2. ST_GeomFromGeojson(geojson) Geojson temsilinden PostGIS geometri verisi oluşturan fonksiyondur. Ancak yalnızca JSON belgesinin geometri kısımları için kullanılmalıdır. Tüm belge için kullanıldığında hataya sebep olacaktır [9].--Örnek Kullanım:SELECT ST_GeomFromGeoJSON('{\"type\":\"Point\",\"coordinates\":[-48.23456,20.12345]}'); Benzer şekilde ST_AsGeoJson fonksiyonu ile geometri verisinden geojson verisi elde edilebilir. 6.3. ST_GeomFromGML(gml) OGC GML formatında tanımlanmış geometri verisini PostGIS geometri verisi formatında döndürür. Ancak yalnızca GML’in geometri kısımları için kullanılmalıdır. Tüm GML belgesinde kullanılması halinde hataya sebep olacaktır [9].-- Örnek Kullanım:SELECT ST_GeomFromGML('\t\t&lt;gml:LineString srsName=\"EPSG:4269\"&gt;\t\t\t&lt;gml:coordinates&gt;\t\t\t\t-71.16028,42.258729 -71.160837,42.259112 -71.161143,42.25932\t\t\t&lt;/gml:coordinates&gt;\t\t&lt;/gml:LineString&gt;');ST_AsGML fonksiyonu kullanılarak PostGIS geometrisinden OGC GML geometri tanımı elde edilebilir.6.4. ST_GeomFromKMLOGC KML temsilinden PostGIS geometri nesnesi oluşturur. KML tanımının yalnızca geometri kısımları için kullanılmalıdır [9]. Aksi takdirde hataya sebep olacaktır.-- Örnek Kullanım:SELECT ST_GeomFromKML('\t\t&lt;LineString&gt;\t\t\t&lt;coordinates&gt;-71.1663,42.2614\t\t\t\t-71.1667,42.2616&lt;/coordinates&gt;\t\t&lt;/LineString&gt;');ST_AsKML fonksiyonu ile postgis geometrisinden OGC KML verisi elde edilebilir. Yine yalnızca geometri kısmı için geçerlidir. 7. Topolojik İlişkiler PostGIS, geometrilerin uzayda birbirine göre durumlarını sınayan bir dizi fonksiyona sahiptir. Bu fonksiyonlar kullanılarak mekansal veriler arasındaki ilişkileri sorgulayabilir aynı zamanda çeşitli mekansal analizleri gerçekleştirebiliriz.Bu bölümde geometrilerin birbirlerine göre durumlarını sınayan PostGIS fonksiyonları üzerinde durulmuştur. A ve B değişkenlerinin birer PostGIS geometrisi olduğu düşünülmelidir. 7.1. ST_Contains(A, B) Girdi olarak iki adet geometri alan bu fonksiyon geometrilerin biribiri içinde olup olmadığını kontrol ederek sonucu boolean bir değer olarak döndürür. B geometrisi, tamamen A geometrisinin içerisinde ise True değer dönecektir [9]. Boolean değer döndürmesi sebebiyle where cümleciği ile ya da join işlemlerinde kullanılabilir.-- Örnek Kullanım: Mahallelerdeki metro istasyonu sayılarını veren mekansal sorguda st_contains foksiyonu kullanılabilir.SELECT neighborhoods.name AS neighborhood_name, COUNT(*) AS number_of_subwayFROM nyc_neighborhoods AS neighborhoodsJOIN nyc_subway_stations AS subwaysON ST_Contains(neighborhoods.geom, subways.geom)GROUP BY neighborhoods.name 7.2. ST_Crosses(A, B) Girdi olarak iki geometri alan bu fonksiyon ile geometrilerin uzayda kesişimi sınanır. Geometrilerin en az bir ortak noktaları varsa ve tümü ortak değilse true değer döndürür [9].-- Örnek Kullanım: Mahalle sınırları ile kesişen yolların adı ve tipini getiren bir sorgu için st_crosses fonksiyonu kullanılabilir.SELECT streets.name, streets.typeFROM nyc_streets as streets, nyc_neighborhoods as neighborhoodsWHERE st_crosses(streets.geom, neighborhoods.geom) 7.3. ST_Disjoint(A, B) İki geometri için uzayda ayrıklığı sınayan fonksiyondur. Eğer paramere olarak alınan iki fonksiyon için bindirme ya da kesişme söz konusu değilse geometriler ayrıktır ve true değer döner. Aksi takdirde false değer dönecektir [9].-- Örnek Kullanım:SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::geometry) as result; 7.4. ST_Equal(A, B) İki geometri mekansal olarak eşit ise true değeri döndürür. Geometrilerin noktalarının sıralaması farklı olsa da aynı geometri yapısında olduğu için true döndürecektir. Eşit operatörüne göre daha iyi sonuç verir [9].-- Örnek Kullanım:SELECT ST_Equals(ST_GeomFromText('LINESTRING(0 0, 10 10)'), ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)')) as result; 7.5. ST_Intersects(A, B) Girdi olarak alınan iki postgis geometri verisi kesişiyorsa true değer döndürür. ST_Overlaps, ST_Touches, ST_Within fonksiyonları ile de kesişim kontrol edilebilir. Bu fonksiyonlardan herhangi biri true değer döndürüyor ise kesişim vardır denebilir. ST_Disjoint fonksiyonu ayrıklığı temsil ettiği için true değer döndürmesi durumunda kesişim yoktur [9].-- Örnek Kullanım: Mahalle sınırlarını kesen en uzun yolSELECT \tMAX(st_length(nyc_streets.geom)) AS en_uzun_yolFROM nyc_streets, nyc_neighborhoods WHERE st_intersects(nyc_streets.geom, nyc_neighborhoods.geom); 7.6. ST_Overlaps(A, B) Girdi olarak alınan geometriler mekansal olarak örtüşüyorsa true değeri döndürür. Burada örtüşmeden kasıt kesişmenin olması ancak geometrilerden birinin diğerini tam olarak içermemesidir [9].-- Örnek Kullanım:SELECT st_overlaps(nyc_census_blocks.geom, nyc_neighborhoods.geom) as result, COUNT(*)FROM nyc_census_blocks, nyc_neighborhoodsGROUP BY result 7.7. ST_Touches(A, B) Parametre olarak alınan geometriler kesişiyor ancak bu kesişim noktası geometrilerin sınır noktasındaysa true döndürür. Nokta geometriler için sınır söz konusu olmadığından bu fonksiyon için daima false değer dönecektir [9].-- Örnek Kullanım:SELECT \tST_Touches(public.nyc_census_blocks.geom, public.nyc_neighborhoods.geom) as result, \tCOUNT(*) as number_of_touchesFROM public.nyc_neighborhoods, public.nyc_census_blocksGROUP BY result 7.8. ST_Within(A, B) A geometrisi tamamen B geometrisinin içindeyse true döndürür. Ancak bu ve diğer mekansal ilişki fonksiyonlarının anlamlı bir sonuç üretebilmesi için verilerin aynı koordinat sisteminde olması gerekmektedir [9].ST_Within(A,B) ve ST_Within(B,A) aynı anda true değer döndürüyor ise, o zaman iki geometrinin uzamsal olarak eşit olduğu kabul edilir.-- Örnek Kullanım: Mahalle bazlı cinayet sayılarının bulunmasıSELECT \tnyc_neighborhoods.name, \tCOUNT(*) as number_of_homicidesFROM public.nyc_homicides, public.nyc_neighborhoodsWHERE st_within(nyc_homicides.geom, nyc_neighborhoods.geom)GROUP BY nyc_neighborhoods.nameORDER BY number_of_homicides DESC 8. Ölçüm Fonksiyonları PostGIS veri tabanında depolanan geometri verileri için yine PostGIS fonksiyonları kullanılarak uzunluk, alan, çevre hesabı gibi birçok hesap yapılabilir. 8.1. ST_Area(A) Parametre olarak aldığı çokgenin alanını döndürür. Geometri verileri için alan hesaplama işleminde koordinat sisteminin metrik olmasına dikkat edilmelidir. Çünkü hesaplanan alan koordinat sisteminin biriminde dönecektir [9].-- Örnek Kullanım: Mahallelerin alanlarını hesaplayıp büyükten küçüğe sıralanmasıSELECT name, st_area(geom) AS areaFROM nyc_neighborhoodsORDER BY area DESC 8.2. ST_ClosestPoint(A, B) A geometrisinde B geometrisine en yakın olan iki boyutlu nokta verisini geri döndürür. 3 boyutlu geometriler için ST_3DclosestPoint fonksiyonu tercih edilmelidir [9].-- Örnek Kullanım: SELECT ST_ClosestPoint(\tST_GeomFromText('POINT(100 100)'),\tST_GeomFromText('LINESTRING (20 80, 98 190, 110 180, 50 75 )')); 8.3. ST_Distance(A, B) Parametre olarak aldığı iki geometri verisi arasındaki minimum 2 boyutlu mesafeyi döndürür. Çıktı olarak üretilen sonuç koordinat sisteminin biriminde olacaktır. Metrik bir koordinat sisteminde çalışılmıyorsa dönüşüm yapmak gerekmektedir [9].-- Örnek Kullanım:SELECT ST_Distance(\tST_GeomFromText('POINT(26 32)', 26918), \tST_GeomFromText('POINT(26 45)', 26918));-- Çıktı: 13 8.4. ST_Length(A) Çizgisel geometrilerin uzunluğunu hesaplayan fonksiyondur. Sonucun birimi koordinat sisteminin sahip olduğu birim ile aynı olacaktır. Alan geometrileri için 0 döndürür. Alan geometrilerin çevresini hesaplamak için ST_Perimeter fonksiyonu kullanılmalıdır [9].-- Örnek Kullanım: Sokak uzunluklarını bulurken kullanılabilir.SELECT\tid,\tname,\ttype,\tst_length(geom) AS street_lengthFROM nyc_streetsORDER BY street_length DESC 8.5. ST_Perimeter(A) Alan geometrileri için çevre hesaplamaya olanak tanıyan fonksiyondur. Çıktı olarak üretilen sonuç koordinat sistemi biriminde olacaktır. Alan ifade etmeyen veriler için (nokta, çizgi ve türevleri) 0 değerini döndürür [9].-- Örnek Kullanım: Mahalle sınır çevresini hesaplarken kullanılabilir.SELECT\tname,\tst_perimeter(geom) AS perimeterFROM\tnyc_neighborhoodsORDER BY perimeter DESC; 9. Bindirme Fonksiyonları Topolojik fonksiyonlar ile mekansal ilişkilerin sınanması sonucu boolean değer döner. Bindirme fonksiyonları kullanıldığında mekansal verileri kesişim, birleşim ve fark bulma gibi fonksiyonlara tabi tutarak bu işlemler sonucunda meydana gelen yeni geometriler üretilebilir. 9.1. ST_Intersection(A, B) Parametre olarak aldığı iki geometrinin kesişimini yeni bir geometri olarak döndürür. Başka bir deyişle geometrilerin paylaşılan kısmını döndürür. Geometrilerin paylaşılan bir kısmı söz konusu değil ise uygun tipte boş bir geometri döndürür [9].-- Örnek Kullanım: Bensonhurst mahallesine ait nüfus sayım bloklarıSELECT st_intersection(nyc_neighborhoods.geom, nyc_census_blocks.geom) FROM public.nyc_census_blocks, public.nyc_neighborhoodsWHERE nyc_neighborhoods.name = 'Bensonhurst' 9.2. ST_Union(A, B) Girdi olarak aldığı geometrileri birleştirir ve yeni bir geometri verisi döndürür. Yeni geometride üst üste binmeler yer almaz. Veriler tekilolarak birleştirilir [9].-- Örnek Kullanım: Cinayet noktalarını boroname sütununa göre gruplayıp birleştirmekSELECT ST_Union(geom)FROM nyc_homicidesGROUP BY boroname 9.3. ST_Difference(A, B) A geometrisi ile B geometrisinin kesişmeyen kısmını yeni bir geometri olarak döndürür. Bu işlem A – ST_Intersection(A,B) ile eşdeğerdir. A geometrisinin tamamen B içerisinde yer aldığı durumda boş geometri döndürür [9].-- Örnek Kullanım:SELECT ST_Difference( ST_GeomFromText('POLYGON((1 2, 1 8, 3 8, 3 2, 1 2))', 26918), ST_GeomFromText('POLYGON((1 2, 1 4, 3 4, 3 2, 1 2))', 26918) );-- Çıktı: Geometrilerin paylaşılmayan kısmını döndürür. 9.4. ST_SymDifference(A, B) A ve B geometrilerinin kesişmeyen kısımlarını temsil eden bir geometri döndürür. Bu, ST_Union(A,B) - ST_Intersection(A,B) ile eşdeğerdir. ST_SymDifference(A,B) = ST_SymDifference(B,A) olduğundan simetrik fark olarak adlandırılır [9].-- Örnek Kullanım:SELECT ST_SymDifference( ST_GeomFromText('POLYGON((1 2, 1 8, 3 8, 3 2, 1 2))', 26918), ST_GeomFromText('POLYGON((1 2, 1 4, 3 4, 3 2, 1 2))', 26918) ); 10. Geometri İşleme Fonksiyonları Geometri işleme fonksiyonları, parametre olarak aldığı geometriler üzerinde hesaplamalar yapabilirken bu geometrilerin şeklini ve boyutunu değiştirebilir. 10.1. ST_Buffer(geom, buffer_radius) Buffer, türkçesi ile ifade etmek gerekirse tampon analizi CBS yazılımlarının en sık kullanılan analizlerinden biridir. Bu analiz ile bir girdi olarak alınan geometri, girdi olarak alınan radius değeri kadar genişletilerek yeni bir geometri oluşturulur ve etkilenen alanlar ya da nesneler çeşitli mekansal fonksiyonlar kullanılarak belirlenebilir. Radius değeri negatif bir değer olarak belirlenirse giriş geometrisi genişletilmek yerine küçültülür. Ancak nokta ve çizgi geometriler negatif radius değeri için daima boş bir geometri döndürecektir [9].Tampon fonksiyonu da yine koordinat sistemi birimine bağlıdır. Koordinatların enlem ve boylam ile ifade edildiği koordinat sistemlerinde radius değeri metre ile ifade edilirse birim uyuşmazlığından kaynaklı yanlış sonuçlar meydana gelecektir. Radius değeri koordinat sisteminin birimi ile uyumlu şekilde belirlenmektedir.--- Örnek Kullanım: Metro istasyonlarına 200 metre mesafede işlenen cinayetlerSELECT\tnyc_homicides.*FROM nyc_homicidesINNER JOIN nyc_subway_stations \ton ST_Within(nyc_subway_stations.geom, ST_Buffer(nyc_homicides.geom, 100)) 10.2. ST_Centroid(geom) Her bir geometri verisi için uygun şekilde kütle merkezini hesaplayarak sonucu bir nokta geometrisi olarak döndürür [9].-- Örnek Kullanım:SELECT \tst_centroid(geom) as centroid_of_eastharlem, \tgeom as eastharlemFROM nyc_neighborhoodsWHERE name = 'East Harlem' 10.3. ST_SharedPaths(geomA, geomB) Parametre olarak aldığı iki geometri tarafından paylaşılan yolları içeren yeni bir geometri döndürür [9].-- Örnek Kullanım: SELECT ST_SharedPaths( ST_GeomFromText('MULTILINESTRING((26 125,26 200,126 200,126 125,26 125), (51 150,101 150,76 175,51 150))'), ST_GeomFromText('LINESTRING(151 100,126 156.25,126 125,90 161, 76 175)') );-- Aradaki fark bu geometrilerden gözlenebilir. SELECT ST_GeomFromText('MULTILINESTRING((26 125,26 200,126 200,126 125,26 125), (51 150,101 150,76 175,51 150))'), ST_GeomFromText('LINESTRING(151 100,126 156.25,126 125,90 161, 76 175)'); 10.4. ST_Simplify(geom, ref) ST_Simplify fonksiyonu Douglas-Peucker algoritmasının kullanılmasıyla girdi olarak aldığı PostGIS geometrisinin \"basitleştirilmiş\" bir versiyonunu döndürür. Genellikle MultiLine ya ve MultiPolygon veriler ile kullanılmaktadır ancak herhangi bir geometri ile kullanıldığında da hataya sebep olmamaktadır [9].Bir referans değeri verilerek basitleştirme yapılırsa çok sayıda küçük nesnenin haritadan kaybolmasının ve haritada boşluklara sebep olmasının önüne geçilebilir.-- Örnek Kullanım:SELECT ST_Simplify(geom,10)FROM nyc_neighborhoods-- Parametre olarak aldığı tam sayı değeri artırılarak aradaki değişim gözlenebilir. 11. Sonuç Bu yazıda günümüzde oldukça popüler olan en güçlü açık kaynak kodlu veri tabanı yönetim sistemlerinden biri olan PostgreSQL'in etkin mekansal veri yönetim aracı PostGIS ve mekansal fonksiyonları üzerinde durulmuştur. PostGIS çok güçlü bir mekansal veri yönetim aracıdır ve arkasındaki açık kaynak geliştirici topluluğu sayesinde gelişmeye devam etmektedir.Günümüzde üretilen verinin çok büyük bir bölümünün konumsal olduğu düşünüldüğünde çıkarılabilecek faydalı bilgi ihmal edilemeyecek düzeydedir. PostGIS aracıyla PostgreSQL mekansal veriden faydalı bilgi çıkarmakta etkin ve kullanışlı bir yol sunmaktadır. 12. Referanslar [1]\tH. Uyguçgil, E. Ergün, ve E. M. Bektöre, Konumsal Veritabanı I. Türkiye: Anadolu Üniversitesi, 2018.[2]\tN. Matthew ve R. Stones, Beginning Databases with PostgreSQL: From novice to professional. Apress, 2006.[3]\tL. Perkins, Seven Database in Seven Weeks, 2. bs. The Pragmatic Programmers, 2018.[4]\tS. Agarwal ve K. S. Rajan, “Performance Analysis of MongoDB versus PostGIS/PostGreSQLDatabases for Line Intersection and Point Containment Spatial Queries”, s. 7, 2016.[5]\tE. Baralis, A. Dalla Valle, P. Garza, C. Rossi, ve F. Scullino, “SQL versus NoSQL databases for geospatial applications”, içinde 2017 IEEE International Conference on Big Data (Big Data), Boston, MA, Ara. 2017, ss. 3388-3397. doi: 10.1109/BigData.2017.8258324.[6]\tA. Marquez, PostGIS Essentials. PACT, 2015.“PostgreSQL Documentation”. 2022. [Çevrimiçi]. Erişim[8] “PostGIS Workshop”. 2022. [Çevrimiçi]. Erişim[9] “PostGIS Documentation”. 2022. [Çevrimiçi]. Erişim" } ]
